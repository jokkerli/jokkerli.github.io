<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaLearn(1)</title>
    <link href="/2024/05/14/JavaLearning514/"/>
    <url>/2024/05/14/JavaLearning514/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaLearn514"><a href="#JavaLearn514" class="headerlink" title="JavaLearn514"></a>JavaLearn514</h1><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><ol><li><strong>getClass</strong>   navtive方法，获取该对象的Class对象，Class对象就是字节码文件，保存在堆中。</li><li><strong>hashCode</strong>   native方法，主要作用就是获得该对象的哈希值，哈希算法就是一种将数据转换为固定大小输出值的算法，例如String类中的hashCode就重写了，具体算法是依次遍历每个字符，初始h为0， h &#x3D; h * 31 + value[i] 。为什么是31，因为31是是一个奇质数，质数能减少哈希碰撞的概率，而且31比较好计算，左移五位后再删除自身。</li><li><strong>equals</strong>   用于比较两个对象，未重写即是 <code>this == obj</code> 的形式，比较两个对象的引用地址。子类需要比较时一般要重写这个方法。</li><li><strong>clone</strong> native方法，实现对象的浅拷贝。只有实现了Cloneable接口才可以调用该方法。否则会抛出CloneNotSupportException异常。浅拷贝和深拷贝是复制对象时的两种不同策略。浅拷贝创建的是一个新对象，这个新对象拥有和原始对象相同的属性值。如果是基本数据类型，则复制属性值，如果是引用数据类型，则会复制该属性指向的内存地址，而不是该属性指向的实际对象。深拷贝则是会递归的复制一个原始对象的所有引用对象。</li><li><strong>toString</strong> 返回一个String对象，一般子类都有覆盖。默认返回格式如下：<code>getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode())</code>。</li><li><strong>wait</strong>(time) 将该线程暂停，放弃当前持有的锁，进入的对应的对象锁的监视器的等待集中。  </li><li><strong>notify</strong> 用于唤醒在该对象上等待的某个线程。用于唤醒在该对象的监视器的等待集里头的线程</li><li><strong>finalize</strong> 该方法是保护方法，主要用于在GC的时候再次被调用，如果我们实现了这个方法，对象可能在这个方法中再次复活，从而避免被GC回收。</li></ol><h2 id="Thread的方法"><a href="#Thread的方法" class="headerlink" title="Thread的方法"></a>Thread的方法</h2><ol><li><strong>start</strong> 实例方法，java虚拟机调用此线程的run方法</li><li><strong>sleep</strong> 使当前正在执行的线程暂停执行指定的时间，以让其他线程执行</li><li><strong>yield</strong> 暗示调度器当前线程愿意让出当前的CPU资源</li><li><strong>join</strong> 实例方法，加入的意思，等待这个线程终止。一般是在一个线程调用另一个线程，使其加入，即执行加入的线程先。</li><li><strong>interrupt</strong> 实例方法，用于中断线程</li><li><strong>stop</strong> 强制终止线程，已弃用，不安全</li><li><strong>currentThead</strong> 返回对当前正在执行的线程对象的引用</li><li><strong>getName getId getpriority getState</strong> 返回线程名称 标识符 优先级 状态，也有对应的set方法</li></ol><h2 id="wait-和sleep-的区别"><a href="#wait-和sleep-的区别" class="headerlink" title="wait()和sleep()的区别"></a>wait()和sleep()的区别</h2><ol><li>wait是Object的实例方法，每个对象都有这个方法，常用的就是直接wait()，表示执行当前方法的线程<strong>释放</strong>它持有的对象锁，进入到锁的等待集中，允许其他线程进入同步代码块或方法。需要在synchronized代码块或者wait方法中使用，否则会排除illegalMonitorStateException异常，因为要调用wait之前需要持有一个对象锁。需要通过notify()方法唤醒当前对象锁上等待的线程。平时一般都是在一个类中写这些方法，当前线程和对象都是同一个。</li><li>sleep是Thread的静态方法，执行sleep()方法时它<strong>不会释放</strong>任何锁。可以在任何地方使用，不需要在同步代码块中。通常用于延迟执行，或者在特定的时间内让出CPU给其他线程执行。</li></ol><h2 id="synchronized和ReentrantLock的原理和区别"><a href="#synchronized和ReentrantLock的原理和区别" class="headerlink" title="synchronized和ReentrantLock的原理和区别"></a>synchronized和ReentrantLock的原理和区别</h2><ol><li><p><strong>对象创建流程</strong>：通过new关键字创建对象时，一般是先检查对象对应的类是否已加载，未记载则执行对应的类加载（加载，链接（验证、准备、解析）、初始化），加载后分配内存，内存分配策略有指针碰撞和空闲列表两种方式。接着初始化零值，对属性赋值。<strong>设置对象头</strong>，执行 init 方法，也就是构造器方法，父类子类构造器合在一起。</p></li><li><p><strong>对象头信息</strong>：Mark Word（哈希码、GC代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳） 和类型指针（指向它的类元数据的指针）和数组长度。MarkWord的长度一般跟JVM的位数一致，例如JVM是64位，MarkWord就是64位。为了能使用更少的位数存放更多的信息，最低的2位的用来标志为锁的类型，根据锁的类型的不同，前面的位表示的信息也不同。例如当是重量级锁时前62位是ptr-to-heavyweight-monitor，表示指向monitor对象（也称为管程或监视器锁）的起始地址。</p></li><li><p><strong>synchronized的原理</strong>：涉及JVM中的监视器锁或者对象锁机制,每个对象有对应的监视器monitor，也和对象的对象头信息有关。可以修饰方法和代码块，修饰时需要传递一个对象作为锁。当一个线程访问某个对象的synchronized方法时，他会自动获取这个方法所属对象的锁。</p></li><li><p><strong>监视器</strong>：用于实现线程之间的的互斥和协作。每个java对象都可以关联一个监视器，如果另一个线程视图进入使用同一个监视器锁保护的另一个同步代码段，它会被阻塞直到监视器被释放。监视器的实现通常包含以下几个部分：锁（Lock）、等待集（Wait Set）[线程调用wait()方法时它会被放入到监视器的等待集中，处于等待集中的线程不会竞争锁，而是等待被notify()或者notifyAll()方法唤醒]、计数器[]。</p></li><li><p><strong>synchronized锁的状态</strong>：有多种状态，如无锁状态、偏向锁、轻量级锁和重量级锁。他们在不同情况下会通过CAS、自旋等方式及逆行锁状态转换，以提高同步的效率。</p></li><li><p><strong>对象锁的状态变化</strong>： 一开始是无锁状态，当第一个线程尝试进入synchronized方法时，如果没有其他线程竞争该锁，则JVM会将对象头的Mark Word更新为偏向锁的状态。根据情况的不同，偏向锁升级为轻量级锁或者重量级锁。轻量级锁适用于多线程交替执行同步块的情况，而非同时竞争。重量级锁同时竞争同一把锁的情况。</p></li><li><p><strong>偏向锁的理解</strong>：偏向，就是倾向的意思，偏向锁即时偏向于第一个获取它的线程。在多线程的应用程序中，很多情况下锁往往是由一个线程多次连续获取，传统的锁机制（轻量级锁和重量级锁）每次在进入和退出临界区时都需要进行一些列复杂的同步操作。即使没有其他线程竞争该锁，这些操作在无竞争的情况下引入了不必要的性能开销。偏向锁就是为了优化这种情况而引入的。</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2024/03/07/Git/"/>
    <url>/2024/03/07/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h1><p>🦐🦀🦞</p><h2 id="Git的基础介绍"><a href="#Git的基础介绍" class="headerlink" title="Git的基础介绍"></a>Git的基础介绍</h2><p>🦞 <strong>基本介绍</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tex">Git是一个分布式版本控制系统。<br><br>版本控制，即一种记录文件内容变化，一边将来查阅特定版本修订情况。用户能够查看历史版本，方便版本之间的切换。<br><br>分布式，与之相反的是集中式。常见集中式版本控制工具由CVS、SVN（Subversion）、VSS...。<br>集中式则是一个单一的集中管理的服务器，保存所有文件的修订版本，工作者通过客户端连接服务器，取得最新文件或者提供更新。但一旦服务器宕机，后果很严重。<br><br>分布式，工作者吧代码从仓库完整地镜像到本地库，在本地库进行修改。在本地进行版本控制。<br></code></pre></td></tr></table></figure><p>🦞 <strong>工作原理</strong></p><p><img src="/2024/03/07/Git/image-20240307220422821.png" alt="image-20240307220422821">Git</p><h2 id="Git的基本指令"><a href="#Git的基本指令" class="headerlink" title="Git的基本指令"></a>Git的基本指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 初始化本地库<br>git init<br>2.查看本地库状态<br>git status<br>3. 添加暂存区，当文件名为 . 时，表示当前目录下所有文件<br>git add 文件名<br>4. 提交到本地库<br>git commit -m “日志信息” 文件名<br>5. 查看历史版本<br>git relog/log<br>6. 切换版本<br>git reset -- hard 版本号<br></code></pre></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>🦞 <strong>何为分支</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务地单独分支。使用分支以为这程序员可以把自己地工作从开发主线分离开来，开发自己分支的时候，不会影响主线的运行。<br><br>分支底层其实也是指针的引用。<br></code></pre></td></tr></table></figure><p>🦞 <strong>分支的基本操作</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.查看分支<br>git branch -v<br>2.切换分支<br>git checkout 分支名<br>3.创建分支<br>git branch 分支名<br>4.合并分支，将指定的分支合并到当前分支上<br>git merge 分支名<br></code></pre></td></tr></table></figure><p>🦞 <strong>合并分支时产生冲突</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">合并分支时，两个分支在同一个文件的同一个位置由两套王权不同的修改，Git无法替我们决定使用哪一个，即需认为决定新代码的内容。<br></code></pre></td></tr></table></figure><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>🦞 <strong>远程仓库基本指令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 拉取仓库代码，将远程仓库对于分支最新内容拉下来后于当前分支直接合并<br>git pull 远程仓库地址别名 远程分支名<br>2. 上传仓库代码，推送本地分支上的内容到远程仓库<br>git push 别名 本地分支<br>3. 克隆仓库代码，<span class="hljs-built_in">clone</span> = 拉取代码 + 初始化本地仓库 + 创建别名（origin）<br>git <span class="hljs-built_in">clone</span> 远程地址<br>4. 建立仓库连接<br>git remote add 别名 远程地址<br>5. 查看当前所有远程地址别名<br>git remote -v<br></code></pre></td></tr></table></figure><p>🦞 <strong>跨平台团队写作</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">首先通过fork将指定的仓库代码复制到自己的github仓库，然后对自己的github仓库代码拉到本地，进行修改创作等等，再推回github仓库。最后向原仓库提交PR，也就是pull request。在PR里头可以看到相关信息。<br></code></pre></td></tr></table></figure><h2 id="工作中正确使用git"><a href="#工作中正确使用git" class="headerlink" title="工作中正确使用git"></a>工作中正确使用git</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tex">1、 先把master主分支上的代码与远程仓库同步到最新版本。直接从远程仓库pull下来<br>2、 在本地创建并切换到工作分支，创建完成后会自动切换到该分支（这时候master/work分支的内容是相同的。）<br>3、 编写代码。<br>4、 完成后，add commit到work分支<br>5、 将主分支从远程仓库pull最新的版本下来。<br>6、 将工作分支合并到主分支<br>先切换到主分支master<br>选中要合并的分支work，点击merge<br>如果有冲突，则需要手动解决冲突<br>7、 这时候所有在work分支上做得修改就会合并到主分支上。<br>8、 最后就可以push到远程仓库上了。<br>关于分支切换的两个注意点<br><br>分支切换一定要先add/commit当前分支上的修改，然后如果在修改完代码后没有提交，就想切换，idea会提示是否进行smart checkou，如果你点击yes你就完完了，idea会把当代分支上的修改，保存到你要切换的另一个分支上。这样一样就乱套了。<br>如果当前工作分支上有很多bug不想提交，那么你可以先隐藏当前工作分支上的修改，stash（隐藏），然后切换到另一个分支上，那么下次你又切换回工作分支的时候，你可以通过unstash把修改的代码重新显示出来。<br></code></pre></td></tr></table></figure><p>🦞 <strong>引用</strong></p><p><a href="https://blog.csdn.net/weixin_44190665/article/details/118024018">尚硅谷2021最新Git教程笔记_idea集成gitlab mac-CSDN博客</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL架构篇</title>
    <link href="/2024/03/06/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87/"/>
    <url>/2024/03/06/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="架构篇"><a href="#架构篇" class="headerlink" title="架构篇"></a>架构篇</h2><h3 id="数据目录"><a href="#数据目录" class="headerlink" title="数据目录"></a>数据目录</h3><p>🤥 <strong>表在文件系统中的表示</strong></p><p>​😀 <strong>表结构（以innodb为例）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">表名.frm<br>用于描述表结构的文件，是以二进制格式存储的。<br><br>CREATE TABLE test(<br>c1 INT;<br>    C2 VARCHAR(10)<br>);<br></code></pre></td></tr></table></figure><p>​😀 <strong>系统表空间和独立表空间</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">表空间：用于存放表的数据和索引<br>系统表空间：版本低时采用的策略，所有表的数据和索引都存放在此，大小为12M，且可拓展。文件表名通常为ibdata1。<br>独立表空间：每个表对应属于自个的表空间，文件格式为“表名.ibd”。<br><br>MySQL8.0中不再单独提供b.frm，二十合并在b.ibd文件中。<br>相比于innodb，myisam则是产生3个文件，除了b.frm(5.7)/b.xxx.sdi(8.0)还有b.MYD和b.MYI，分别存放数据和索引。<br></code></pre></td></tr></table></figure><h3 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h3><p>🤥 <strong>剖析逻辑架构</strong></p><p><img src="/2024/03/06/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87/image-20240304172052923.png"></p><p>​😀 <strong>连接层</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">访问MySQL服务器前，第一件事就是建立TCP链接。涉及到了三次握手（计网知识）。<br>TCP链接收到请求后，会分配给一个线程与这个客户端进行交互，所以还会有个线程池。<br>有了线程池，省去了创建和销毁的开销。<br></code></pre></td></tr></table></figure><p>​😀 <strong>服务层</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tex">SQL Interface SQL接口 --&gt;  Parser 解析器--&gt;  Optimizer 查询优化器<br><br>SQL接口：接收SQL命令，并且返回查询结构。例如select * from xxx；<br><br>解析器：对SQL命令进行语法解析和语义解析，转换成数据结构，若在转换过程中发生错误，则代表SQL语句不合法。<br><br>查询优化器：语法解析之后、查询之前会使用查询优化器确定SQL的执行路径，生成一个 执行计划 。<br>执行计划会表明使用哪些 索引 进行查询，表之间连接顺序如何等等。例如有“选取-投影-连接”策略。<br>先进行where，再选择对应属性列，再进行表之间的连接。<br><br>查询缓存：缓存SQL查询结果，由于命中率低，在MySQL8.0中已删除。<br></code></pre></td></tr></table></figure><p>​😀 <strong>引擎层</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">全称为插件式存储引擎层。真正负责数据的存储和提取，对物理服务器级别维护的底层数据执行操作，服务器通过API与存储引擎进行通信。<br>默认的MySQL的存储引擎为InnoDB，支持事务，行级锁，外键。<br></code></pre></td></tr></table></figure><p>​😀 <strong>存储层</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">所有的数据（表数据、索引，数据库信息等）都存在文件系统中。<br></code></pre></td></tr></table></figure><p>🤥<strong>SQL执行流程</strong></p><p><img src="/2024/03/06/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87/image-20240304172159984.png" alt="image-20240304172159984"></p><p>​😀 <strong>SQL执行流程文字描述</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">1. 建立CS通信连接<br>2. 查询缓存<br>3. 对SQL语句进行语法分析、语义分析，生成对应语法树（即为图中的语法解析和预处理）<br>4. 确定执行路径，生成执行计划，包括逻辑查询优化和物理查询优化。<br>5. 执行生成的执行计划<br></code></pre></td></tr></table></figure><p>😀 <strong>SQL语法顺序</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">优化器会分析不同的执行顺序产生的性能消耗不同而动态调整执行顺序。下表是常见的查询顺序。<br></code></pre></td></tr></table></figure><p><img src="/2024/03/06/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87/image-20240304204224911.png" alt="image-20240304204224911"></p><p>😀 <strong>profiles、profiling、profile的使用</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">使用profile可以查看SQL语句的详细执行步骤<br><br>有全局参数 profiling， 使用 select @@profiling ，即可查看。默认该功能关闭，可通过 set profiling = 1 进行设置。<br><br>使用 show profiles 可以查看当前会话所产生的最近几次查询<br><br></code></pre></td></tr></table></figure><p>🤥<strong>数据库缓冲池</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">略<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown基本语法</title>
    <link href="/2024/03/03/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2024/03/03/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="MarkDown语法"><a href="#MarkDown语法" class="headerlink" title="MarkDown语法"></a>MarkDown语法</h1><p>[TOC]</p><h3 id="标题（-）"><a href="#标题（-）" class="headerlink" title="标题（#）"></a>标题（#）</h3><p>标题采用 # 来标注</p><h3 id="强调（-）"><a href="#强调（-）" class="headerlink" title="强调（*）"></a>强调（*）</h3><p>粗体的话使用两个 ** ，斜体的话使用一个 *</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">正常   ** 粗体 **    <span class="hljs-emphasis">*斜体*</span>     <span class="hljs-strong">**<span class="hljs-emphasis">*粗斜体*</span>**</span> <br></code></pre></td></tr></table></figure><h3 id="引用-（-）"><a href="#引用-（-）" class="headerlink" title="引用 （&gt;）"></a>引用 （&gt;）</h3><p>引用的话使用 &gt;</p><blockquote><p>这是引用</p></blockquote><h3 id="列表-（-）"><a href="#列表-（-）" class="headerlink" title="列表 （-）"></a>列表 （-）</h3><p>列表分为有序和无序，有序使用数字加英文小数点，无序使用 - * + 任一。要在保留列表的连续性的同时在列表中添加另一种元素，请将改元素缩进四个空格或一个制表符。</p><ol><li><p>有序第一条</p></li><li><p>有序第二条</p><ol><li><p>这是缩进</p><blockquote><p>这是列表中的另一个元素</p></blockquote></li><li><p>这是缩进</p></li></ol></li></ol><ul><li>无序第一条</li><li>无序第二条</li></ul><h3 id="代码（-）"><a href="#代码（-）" class="headerlink" title="代码（&#96;）"></a>代码（&#96;）</h3><p> 这个符号叫反引号，用法类似于强调的 *，一两层 &#96; 表示 代码，可在两层中使用一层，类似于python的引号， 三层则是代码块</p><p><code>int</code></p><p><code>int</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">这是java代码块</span><br><span class="hljs-comment">**/</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="分割线（-，—-）"><a href="#分割线（-，—-）" class="headerlink" title="分割线（***，—,___）"></a>分割线（***，—,___）</h3><p>分割线有三种，需要在单独一行里使用。建议使用 —，渲染效果都一样</p><hr><hr><hr><h3 id="链接-超链接显示名-超链接地址-“超链接标签”"><a href="#链接-超链接显示名-超链接地址-“超链接标签”" class="headerlink" title="链接 [超链接显示名] (超链接地址 “超链接标签”)"></a>链接 [超链接显示名] (超链接地址 “超链接标签”)</h3><p>超链接标签是鼠标停在链接上显示的提示词。一般使用鼠标右键来创建超链接，或者直接复制链接到笔记里头。</p><p><a href="https://markdown.com.cn/basic-syntax/links.html">Markdown 链接语法 | Markdown 官方教程</a></p><p>使用尖括号可以很方便地把URL或者email地址变成可点击的链接。</p><p><a href="https://jokkerli.github.io/">https://jokkerli.github.io/</a></p><h3 id="图片-图片显示名-图片"><a href="#图片-图片显示名-图片" class="headerlink" title="图片 ![图片显示名] (图片)"></a>图片 ![图片显示名] (图片)</h3><p>类似于超链接，多了一个！。给图片添加链接时，将图片的 ![] () 放入到超链接的[超链接显示名]中即可。</p><p><a href="https://markdown.com.cn/basic-syntax/images.html"><img src="/2024/03/03/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/TyporaMd\90.jpg" alt="老头"></a></p><h3 id="转义字符语法"><a href="#转义字符语法" class="headerlink" title="转义字符语法"></a>转义字符语法</h3><p>要想显示原本用于格式化的mk字符，需在字符前面添加反斜杠字符 \ 。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>表格、公式块、任务列表、链接引用等使用，可通过右键直接添加。</p><p>同时，为了添加笔记的美观，可以适当地添加一些emoji表情。可通过以下链接获得表情。</p><p><a href="https://emojipedia.org/">📙 Emojipedia — 😃 Home of Emoji Meanings 💁👌🎍😍</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>再次学习markdown的语法，为了能更好地写笔记，希望这是一个好的开始吧。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/02/29/hello-world/"/>
    <url>/2024/02/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
