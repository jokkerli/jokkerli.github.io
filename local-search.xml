<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>微服务</title>
    <link href="/2024/06/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <url>/2024/06/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><p>微服务就是将一个大型的单体架构拆分成一组<strong>小型、自治且松耦合</strong>的服务，每个微服务负责执行特定的业务功能，并<strong>通过轻量级通信机制（HTTP）</strong>相互协作。可以独立开发、测试、部署和扩展，使得应用程序更加灵活、可伸缩和可维护。</p><p><img src="/2024/06/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1/1-1717596550156-1.png"></p><p><strong>优势：</strong></p><p><strong>独立部署</strong>：每个微服务都可以独立开发、测试、部署和扩展。可以减少部署的风险和复杂性，提高发布的频率和灵活性。</p><p><strong>技术多样性</strong>：不同的微服务可以使用不同的技术栈（编程语言、数据库、框架等），可以根据具体的需求选择最合适的技术。</p><p><strong>可扩展性</strong>：允许对不同的服务进行独立的扩展。可以根据各个服务的负载情况，单独扩展其某个服务，而不需要整体扩展整个系统。</p><p><strong>故障隔离</strong>；当某个服务出现故障时，不会影响整个系统的运行。</p><p><strong>团队独立性</strong>：每个服务独立，可以灵活地进行开发和发布。</p><p><strong>提高系统的性能</strong>：通过合理的设计和优化，可以将一些高负载的服务进行独立部署和扩展，从而提高系统的整体性能。</p><p><strong>灵活的容错和恢复机制</strong>：允许对不同的服务设计不同的容错和恢复机制，可以针对对关键服务设计高可用和快速恢复的机制，提供系统的容错能力。</p><p>口语：微服务就是将一个大型的单体架构拆分成一组小型、自治、松耦合的服务。每个服务执行特定的业务功能。微服务是从单体架构延申过来的，所以说到优点，肯定就是单体架构的缺点。当一个单体架构的功能不断增多，开发、测试、部署和维护等工作就越来越差。拆分成多个服务，可以独立开发、测试、部署和维护【<strong>独立开发</strong>】，在企业中每个团队也可以独立的进行工作【<strong>团队独立</strong>】。再有单体架构所有模块运行在同一个机器上，机器的压力就会很大，性能就差，也有崩掉的风险。微服务架构拆分成多个服务之后，每个机器只会运行一个小服务，压力降低，崩掉的风险就大幅下降。而且当一个微服务崩了，不会影响整体的系统【<strong>故障隔离</strong>】。同时还可以根据每个服务的不同灵活的选择对应机器配置【<strong>灵活的容错和恢复机制</strong>】。还可以自由的扩展【<strong>可扩展性</strong>】。</p><p><strong>挑战</strong>：</p><p><strong>服务间通信</strong>：微服务之间通过网络进行通信，这就引入了网络延迟、带宽限制和可靠性等问题。常见的通信模式包括HTTP&#x2F;REST、RPC、消息队列等。【openFeign、MQ】</p><p><strong>数据管理</strong>：微服务提倡数据库分离，但这也带来了数据一致性和跨服务事务管理的挑战。需要设计合适的数据同步和一致性策略，如分布式事务、事件驱动架构等。【seata】</p><p><strong>分布式系统复杂性</strong>：微服务有分布式的特性，带来了分布式系统典型的挑战，如网络分区、服务故障、数据复制和一致性等。</p><p><strong>部署和运维</strong>：需要频繁地不俗和和更新多个服务，增加了部署和运维的复杂性。【docker（容器化技术）、Kubernetes（容器编排工具）、CI&#x2F;CD（持续集成&#x2F;持续部署）】</p><p><strong>监控和日志</strong>：系统由多个独立地服务组成，监控和日志管理变得复杂。需要集中化的监控工具和日志收集系统。（ELK）</p><p><strong>服务发现和负载均衡</strong>：随着服务数量的增加，如何动态地发现和管理服务实例、实现负载均衡，是一大挑战。【Eureka、Nacos】</p><p><strong>团队沟通和协作成本</strong>：每个微服务都由专门的团队负责，可能增加团队之间的沟通和协作成本。需要有效的沟通渠道和协作机制，确保服务之间的协调和一致性。</p><p>口语：根据相应工具解决的问题去回答，因为这些工具就是为了解决这些挑战的。</p><p>Nacos：用于服务注册和发现。即管理服务，服务一多了服务的管理就更加复杂。</p><p>openFeign：用于服务之间的通信。微服务拆分成多个微服务，相较于单体架构所有服务运行在同一个进程，调用就很简单很快。而微服务之间的调用就需要使用轻量级的通信协议来实现，例如HTTP和RPC。</p><p>Docker：用户部署。微服务拆分成多个微服务，部署起来就很困难。</p><p>ELK：用于监控和日志管理。系统需要进行监控，进行日志管理，微服务一多监控和管理难起来了。</p><p>seata：用于分布式事务。微服务具有分布式系统的特性，带来了分布式系统典型的挑战，数据一致性的问题。</p><h2 id="单体服务"><a href="#单体服务" class="headerlink" title="单体服务"></a>单体服务</h2><p>单体服务：传统的软件架构风格，将整个应用程序作为一个<strong>单一的</strong>、<strong>紧耦合</strong>的单元进行开发的部署。</p><p>以下是单体架构的特点：</p><p><strong>单一代码库</strong>：所有功能模块共享一个代码块。</p><p><strong>集中式管理</strong>：所有功能模块共享同一个数据库和资源。</p><p><strong>部署简单</strong>：由于所有模块集成在一起，部署时只需一次操作即可完成。</p><p><strong>性能优化</strong>：由于所有模块都在一个进程中运行，模块之间的调用速度块。</p><p><img src="/2024/06/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1/2-1717596379266-7.png"></p><p>优点：</p><p><strong>开发简单</strong> <strong>部署简单</strong> <strong>性能较好</strong></p><p>缺点：</p><p><strong>维护困难 扩展性差 部署风险高 技术栈单一</strong></p><h2 id="微服务流行框架"><a href="#微服务流行框架" class="headerlink" title="微服务流行框架"></a>微服务流行框架</h2><ol><li>Dubbo</li><li>Spring cloud Netfix</li><li>Spring Cloud Alibaba</li></ol><h2 id="微服务的组件"><a href="#微服务的组件" class="headerlink" title="微服务的组件"></a>微服务的组件</h2><ol><li>注册中心：用于服务的注册与发现，管理微服务的地址信息，常见的实现包括：<ol><li>Spring cloud Netflix：Eureka、Consul</li><li>Spring cloud Alibaba：Nacos</li></ol></li><li>配置中心：用于几种管理微服务的配置信息，可以动态修改配置而不需要重启服务。常见的实现包括：<ol><li>Spring cloud Netflix：Spring cloud Config</li><li>Spring cloud Alibaba：Nacos config</li></ol></li><li>远程调用：用于在不同的微服务之间进行通信和协作。常见的实现包括：<ol><li>RESRful API：如rest template 、Feign</li><li>RPC（远程过程调用）：如Dubbo、gRPC</li></ol></li><li>API网关：作为微服务架构的入口，统一暴露服务，并提供路由、负载均衡、安全认证等功能，常见的实现包括：<ol><li>Spring cloud Netflix：Zuul、Gateway</li><li>Springcloud Alibaba：Gateway、Apisix</li></ol></li><li>分布式事务：保证跨多个微服务的一致性和原子性操作，常见的实现包括：<ol><li>spring CLoud Alibaba：Seata</li></ol></li><li>熔断器：用于防止微服务之间的故障扩散，提高系统的容错能力。常见的实现包括：<ol><li>spring CLoud Netflix：Hystrix</li><li>Spring Cloud Alibaba：Sentinel</li></ol></li><li>限流和降级：用于防止微服务过载，对请求进行限制和降级处理，常见的实现包括：<ol><li>Spring Cloud Netflix：Hystrix</li><li>Spring cloud Alibaba：Sentinel</li></ol></li><li>分布式追踪和监控：用于跟踪和监控微服务的请求流程和性能指标。常见的实现包括：<ol><li>SpringCloud Netflix：Spring Cloud Sleuth + Zipkin</li><li>Spring Cloud Alibaba：SkyWalking、Sentinel Dashboard</li></ol></li></ol><h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><p><strong>服务注册</strong>：各个服务在启动时向注册中心注册自己的网络地址、服务实例信息和其他相关元数据。这样，其他服务就可以通过注册中心获取到当前可用的服务列表。</p><p><strong>服务发现</strong>：客户端通过向注册中心查询特定服务的注册中心，获得可用的服务实例列表。这样客户端就可以根据需要选择合适的服务进行调用。实现了服务间的解耦。</p><p><strong>负载均衡</strong>：决定了服务调用方如何选择一个服务实例进行调用。Ribbon是开源的客户端负载均衡器。常见的负载均衡策略包括：</p><p>​轮询：按顺序依次调用每个服务实例。</p><p>​随机：随机选择一个服务实例进行调用。</p><p>​权重轮询：根据服务实例的权重按顺序依次调用。使用于服务实例的性能茶几较大的情况。</p><p>​最小连接数：选择当前连接数最少的服务实例。</p><p>​一致性哈希：根据请求的某个属性进行哈希计算，选择特定的服务实例。可以确保相同的请求总是被路由到同一个服务实例，适用于需要会话粘性强的场景。如缓存服务、分布式数据库等。一致性哈希主要用于分布式系统中，以解决接待你动态加入和退出对系统负载均衡的影响。他通过将数据和节点映射到一个<strong>环形哈希空间</strong>来实现负载均衡。</p><p><strong>健康检查</strong>：确保健康的服务实例才能被其他服务发现和调用。Nacos支持多种健康检查机制，包括HTTP、TCP和自定义健康检查。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>首先一个服务发起RESTful格式的请求，会被spring cloud的拦截器拦截到，解析其请求路径，得到请求的服务名，请求的资源路径，然后通过负载均衡器根据获取到的服务名去注册中心拉取对应的服务列表，存储在对应的服务中。然后根据设置的负载均衡策略，去选择一个服务实例。修改原先的请求路径，发起真实的请求。</p><p><img src="/2024/06/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1/2-1717596562637-3.png"></p><h3 id="Eruka的实现原理"><a href="#Eruka的实现原理" class="headerlink" title="Eruka的实现原理"></a>Eruka的实现原理</h3><p>Eureka的实现原理，大概可以从这几个方面来看：</p><p> 服务注册与发现: 当一个服务实例启动时，它会向Eureka Server发送注册请求，将自己的信息注册到注册中心。Eureka Server会将这些信息保存在内存中，并提供REST接口供其他服务查询。服务消费者可以通过查询服务实例列表来获取可用的服务提供者实例，从而实现服务的发现。 </p><p>服务健康检查: Eureka通过心跳机制来检测服务实例的健康状态。服务实例会定期向Eureka Server发送心跳，也就是续约，以表明自己的存活状态。如果Eureka Server在一定时间内没有收到某个服务实例的心跳，则会将其标记为不可用，并从服务列表中移除，下线实例。</p><p> 服务负载均衡: Eureka客户端在调用其他服务时，会从本地缓存中获取服务的注册信息。如果缓存中没有对应的信息，则会向Eureka Server发送查询请求。Eureka Server会返回一个可用的服务实例列表给客户端，客户端可以使用负载均衡算法选择其中一个进行调用。</p><h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><p>微服务架构中的每个服务通常需要一些配置信息，例如数据库连接地址、服务端口、日志级别等。这些配置可能因为不同环境、不同部署实例或者动态运行时需要进行调整和管理。微服务的实例一般非常多，如果每个实例都需要一个个地去做这些配置，那么运维成本将会非常大，这时候就需要一个集中化地配置中心，去管理这些配置。</p><p>为什么需要有配置中心？？<strong>集中管理、动态更新配置、多环境配置、配置的版本管理、安全性和访问控制</strong></p><p>配置中心用于<strong>集中管理</strong>和分发配置，配置中心可以帮助你在<strong>多个环境（开发、测试、生产）中管理</strong>配置，并支持<strong>动态更新配置</strong>，从而提高系统的可维护性。</p><h3 id="配置中心的原理"><a href="#配置中心的原理" class="headerlink" title="配置中心的原理"></a>配置中心的原理</h3><p>一句话：<strong>配置信息的CRUD</strong>。</p><p>具体的实现大概可以分成这么几个部分： </p><p><strong>配置信息存储</strong>：Nacos默认使用内嵌数据库Derby来存储配置信息，还可以采用MySQL等关系型数据库。</p><p> <strong>注册配置信息</strong>：服务启动时，Nacos Client会向Nacos Server注册自己的配置信息，这个注册过程就是把配置信息写入存储，并生成版本号。 </p><p><strong>获取配置信息</strong>：服务运行期间，Nacos Client通过API从Nacos Server获取配置信息。Server根据键查找对应的配置信息，并返回给Client。</p><p> <strong>监听配置变化</strong>：Nacos Client可以通过注册监听器的方式，实现对配置信息的监听。当配置信息发生变化时，Nacos Server会通知已注册的监听器，并触发相应的回调方法。</p><p><img src="/2024/06/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1/3-1717596570445-5.png"></p><p>Nacos的在pull的基础上，采用了长轮询来进行配置的动态刷新。在长轮询模式下，客户端定时向服务端发起请求，检查配置信息是否发生变更。如果没有发生变更，服务端会“hold”这个请求，即暂时不返回结果，知道配置发生变化或者达到一定的超时时间。是通过设置一个定时任务来完成的。这种方式可以即使获取最新的配置信息，同时也降低了服务端的压力，避免了大量的长连接占用内存资源。</p><h3 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h3><h3 id="配置共享"><a href="#配置共享" class="headerlink" title="配置共享"></a>配置共享</h3><h2 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h2><h3 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h3><p>Feign是一个<strong>声明式</strong>的Web服务<strong>客户端</strong>，他简化了使用基于HTTP的远程服务的开发。Feign是在RestTemplate和Ribbon的基础上，进一步封装，<strong>使用RestTemplate实现Http的调用，使用Ribbon实现负载均衡</strong>。</p><p><strong>声明式API</strong>：Feign允许开发者使用简单的注解来定义和描述对远程服务的访问。通过使用注解，开发者可以轻松地指定URL、HTTP方法，请求参数，请求头等信息，使用远程调用变得非常直观和易于理解。</p><p><strong>使用过程：</strong></p><p>导入相应依赖，openFeign依赖。</p><p>启用Feign客户端（调用方），注解是@EableFeignClient，</p><p>定义Feign客户端接口（调用方）,注解是@FeignClient(name&#x3D;’server-name’)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = &quot;remote-service&quot;)</span> <span class="hljs-comment">// 指定要调用的服务名称</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RemoteServiceClient</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/api/endpoint/&#123;id&#125;&quot;)</span><br>    String <span class="hljs-title function_">getEndpoint</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> String id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用Feign客户端，在服务中注入并使用Feign客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RemoteServiceClient remoteServiceClient;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">callRemoteService</span><span class="hljs-params">(String id)</span> &#123;<br>        <span class="hljs-keyword">return</span> remoteServiceClient.getEndpoint(id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Feign实现认证传递"><a href="#Feign实现认证传递" class="headerlink" title="Feign实现认证传递"></a>Feign实现认证传递</h3><p>首先，Feign提供了一个拦截器的功能，允许在请求发送前后进行自定义处理。这对于<strong>添加认证信息、日志记录、修改请求参数</strong>等非常有用。Feign提供了<strong>RequestInterceptor接口</strong>，可以通过实现这个接口来定义自定义的拦截逻辑。</p><p>Feign拦截又分为局部拦截和全局拦截。两者的区别就是是否在拦截器上添加注解@configuration。局部拦截则是在对应的FeignClient添加对应的拦截器。</p><p><strong>在请求头中添加认证信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> feign.RequestInterceptor;<br><span class="hljs-keyword">import</span> feign.RequestTemplate;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FeignConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RequestInterceptor <span class="hljs-title function_">requestInterceptor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInterceptor</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(RequestTemplate template)</span> &#123;<br>                <span class="hljs-comment">// 在请求头中添加认证信息</span><br>                template.header(<span class="hljs-string">&quot;Authorization&quot;</span>, <span class="hljs-string">&quot;Bearer &quot;</span> + getToken());<br>            &#125;<br><br>            <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getToken</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-comment">// 获取认证令牌的逻辑，例如从安全上下文中获取</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;your-token&quot;</span>;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实现日志记录和自定义参数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> feign.RequestInterceptor;<br><span class="hljs-keyword">import</span> feign.RequestTemplate;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FeignConfig</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(FeignConfig.class);<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RequestInterceptor <span class="hljs-title function_">requestInterceptor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInterceptor</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(RequestTemplate template)</span> &#123;<br>                <span class="hljs-comment">// 添加日志记录</span><br>                logger.info(<span class="hljs-string">&quot;Feign request to: &quot;</span> + template.url());<br><br>                <span class="hljs-comment">// 添加自定义请求参数</span><br>                template.query(<span class="hljs-string">&quot;customParam&quot;</span>, <span class="hljs-string">&quot;customValue&quot;</span>);<br><br>                <span class="hljs-comment">// 在请求头中添加认证信息</span><br>                template.header(<span class="hljs-string">&quot;Authorization&quot;</span>, <span class="hljs-string">&quot;Bearer &quot;</span> + getToken());<br>            &#125;<br><br>            <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getToken</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-comment">// 获取认证令牌的逻辑，例如从安全上下文中获取</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;your-token&quot;</span>;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="服务容灾"><a href="#服务容灾" class="headerlink" title="服务容灾"></a>服务容灾</h2><h3 id="什么是服务雪崩"><a href="#什么是服务雪崩" class="headerlink" title="什么是服务雪崩"></a>什么是服务雪崩</h3><p>微服务架构中，由于一个服务的故障或者性能问题，依赖的服务还在不断发起请求，或者重试，那么请求的压力会不断的在下游堆积，导致依赖该服务的其他服务也出现故障，进而引发级联式的服务故障。最终导致整个系统的崩溃。</p><p>为了防止服务雪崩，可以采用这些措施：</p><p><strong>服务高可用部署</strong>：确保各个服务都具备高可用性，通过冗余部署、故障转移等方式来减少单点故障的影响。</p><p><strong>限流和熔断</strong>：对服务之间的请求进行限流和熔断，以防止过多的请求涌入导致后端服务不可用。</p><p><strong>缓存和降级</strong>：合理利用缓存来减轻后端服务的负载压力，并在必要时进行服务降级，保证核心功能的可用性。</p><h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>服务熔断是微服务架构中的容错机制，用于保护系统免受服务故障或异常的影响。当某个服务出现故障或异常时，服务熔断可以快速隔离该服务，确保系统稳定可用。 </p><p>它通过监控服务的调用情况，当错误率或响应时间超过阈值时，触发熔断机制，后续请求将返回默认值或错误信息，避免资源浪费和系统崩溃。 </p><p>服务熔断还支持自动恢复，重新尝试对故障服务的请求，确保服务恢复正常后继续使用。</p><h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>服务降级是也是一种微服务架构中的容错机制，用于在系统资源紧张或服务故障时保证核心功能的可用性。 </p><p>当系统出现异常情况时，服务降级会主动屏蔽一些非核心或可选的功能，而只提供最基本的功能，以确保系统的稳定运行。</p><p>通过减少对资源的依赖，服务降级可以保证系统的可用性和性能。 </p><p>它可以根据业务需求和系统状况来制定策略，例如替换耗时操作、返回默认响应、返回静态错误页面等。</p><h3 id="Sentinel怎么实现限流的"><a href="#Sentinel怎么实现限流的" class="headerlink" title="Sentinel怎么实现限流的"></a>Sentinel怎么实现限流的</h3><p>Sentinel式Alibaba开源的一款流量防护组件，主要用于分布式系统中的流量控制、熔断降级和系统负载保护。Sentinel提供了丰富的限流功能，可以帮助开发者在高并发的场景下保护系统的稳定性和可靠性。</p><p>步骤：</p><ol><li>引入依赖</li><li>配置Sentinel</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">transport:</span><br>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span><br>        <span class="hljs-attr">port:</span> <span class="hljs-number">8719</span><br></code></pre></td></tr></table></figure><ol start="3"><li><p>启用Sentinel</p></li><li><p>定义限流规则和降级处理逻辑</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>    <span class="hljs-meta">@SentinelResource(value = &quot;callRemoteService&quot;, blockHandler = &quot;blockHandlerMethod&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">callRemoteService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://remote-service/api/endpoint&quot;</span>;<br>        <span class="hljs-keyword">return</span> restTemplate.getForObject(url, String.class);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">blockHandlerMethod</span><span class="hljs-params">(Throwable ex)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Blocked by Sentinel: &quot;</span> + ex.getClass().getSimpleName();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>配置限流规则</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SentinelConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CommandLineRunner</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(String... args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        initFlowRules();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initFlowRules</span><span class="hljs-params">()</span> &#123;<br>        List&lt;FlowRule&gt; rules = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">FlowRule</span> <span class="hljs-variable">rule</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowRule</span>();<br>        rule.setResource(<span class="hljs-string">&quot;callRemoteService&quot;</span>);<br>        rule.setGrade(RuleConstant.FLOW_GRADE_QPS);<br>        rule.setCount(<span class="hljs-number">1</span>); <span class="hljs-comment">// QPS 限制为 1</span><br>        rules.add(rule);<br>        FlowRuleManager.loadRules(rules);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li>使用Sentinel控制台配置限流规则</li></ol><h2 id="API网关"><a href="#API网关" class="headerlink" title="API网关"></a>API网关</h2><p>API网关是一种中间层服务器，用于集中管理、保护和路由对后端服务的访问。它充当了客户端与后端服务之间的入口点。提供了一组统一的接口来管理和控制API的访问。</p><p>API网关的主要功能包括：</p><ol><li><strong>路由转发</strong>：API网关根据请求的URL路径或其他标识，将请求路由到相应的后端服务。通过配置路由规则，可以灵活地将请求分发给不同地后端服务。</li><li><strong>负载均衡</strong>：API网关可以在后端服务之间实现负载均衡，将请求平均分发到多个实例上，提高系统的吞吐量和可扩展性。</li><li><strong>安全认证与授权</strong>：API网关可以集中处理身份认证和授权，确保只有经过身份认证的客户端才能访问后端服务。他可以与身份提供者（如Oatuh）集成，进行用户认证和授权操作。</li><li></li></ol><h3 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a>Spring Cloud Gateway</h3><p>一个基于Spring WebFlux构建的API网关，提供了动态路由、过滤器、负载均衡等功能。</p><p><strong>引用：路人张的面试笔记 <a href="http://www.mianshi.online/">www.mianshi.online</a></strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>微服务相关知识“</title>
    <link href="/2024/06/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/06/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><p>微服务就是将一个大型的单体架构拆分成一组<strong>小型、自治且松耦合</strong>的服务，每个微服务负责执行特定的业务功能，并<strong>通过轻量级通信机制（HTTP）</strong>相互协作。可以独立开发、测试、部署和扩展，使得应用程序更加灵活、可伸缩和可维护。</p><p><img src="/2024/06/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/1-1717596367311-5.png"></p><p><strong>优势：</strong></p><p><strong>独立部署</strong>：每个微服务都可以独立开发、测试、部署和扩展。可以减少部署的风险和复杂性，提高发布的频率和灵活性。</p><p><strong>技术多样性</strong>：不同的微服务可以使用不同的技术栈（编程语言、数据库、框架等），可以根据具体的需求选择最合适的技术。</p><p><strong>可扩展性</strong>：允许对不同的服务进行独立的扩展。可以根据各个服务的负载情况，单独扩展其某个服务，而不需要整体扩展整个系统。</p><p><strong>故障隔离</strong>；当某个服务出现故障时，不会影响整个系统的运行。</p><p><strong>团队独立性</strong>：每个服务独立，可以灵活地进行开发和发布。</p><p><strong>提高系统的性能</strong>：通过合理的设计和优化，可以将一些高负载的服务进行独立部署和扩展，从而提高系统的整体性能。</p><p><strong>灵活的容错和恢复机制</strong>：允许对不同的服务设计不同的容错和恢复机制，可以针对对关键服务设计高可用和快速恢复的机制，提供系统的容错能力。</p><p>口语：微服务就是将一个大型的单体架构拆分成一组小型、自治、松耦合的服务。每个服务执行特定的业务功能。微服务是从单体架构延申过来的，所以说到优点，肯定就是单体架构的缺点。当一个单体架构的功能不断增多，开发、测试、部署和维护等工作就越来越差。拆分成多个服务，可以独立开发、测试、部署和维护【<strong>独立开发</strong>】，在企业中每个团队也可以独立的进行工作【<strong>团队独立</strong>】。再有单体架构所有模块运行在同一个机器上，机器的压力就会很大，性能就差，也有崩掉的风险。微服务架构拆分成多个服务之后，每个机器只会运行一个小服务，压力降低，崩掉的风险就大幅下降。而且当一个微服务崩了，不会影响整体的系统【<strong>故障隔离</strong>】。同时还可以根据每个服务的不同灵活的选择对应机器配置【<strong>灵活的容错和恢复机制</strong>】。还可以自由的扩展【<strong>可扩展性</strong>】。</p><p><strong>挑战</strong>：</p><p><strong>服务间通信</strong>：微服务之间通过网络进行通信，这就引入了网络延迟、带宽限制和可靠性等问题。常见的通信模式包括HTTP&#x2F;REST、RPC、消息队列等。【openFeign、MQ】</p><p><strong>数据管理</strong>：微服务提倡数据库分离，但这也带来了数据一致性和跨服务事务管理的挑战。需要设计合适的数据同步和一致性策略，如分布式事务、事件驱动架构等。【seata】</p><p><strong>分布式系统复杂性</strong>：微服务有分布式的特性，带来了分布式系统典型的挑战，如网络分区、服务故障、数据复制和一致性等。</p><p><strong>部署和运维</strong>：需要频繁地不俗和和更新多个服务，增加了部署和运维的复杂性。【docker（容器化技术）、Kubernetes（容器编排工具）、CI&#x2F;CD（持续集成&#x2F;持续部署）】</p><p><strong>监控和日志</strong>：系统由多个独立地服务组成，监控和日志管理变得复杂。需要集中化的监控工具和日志收集系统。（ELK）</p><p><strong>服务发现和负载均衡</strong>：随着服务数量的增加，如何动态地发现和管理服务实例、实现负载均衡，是一大挑战。【Eureka、Nacos】</p><p><strong>团队沟通和协作成本</strong>：每个微服务都由专门的团队负责，可能增加团队之间的沟通和协作成本。需要有效的沟通渠道和协作机制，确保服务之间的协调和一致性。</p><p>口语：根据相应工具解决的问题去回答，因为这些工具就是为了解决这些挑战的。</p><p>Nacos：用于服务注册和发现。即管理服务，服务一多了服务的管理就更加复杂。</p><p>openFeign：用于服务之间的通信。微服务拆分成多个微服务，相较于单体架构所有服务运行在同一个进程，调用就很简单很快。而微服务之间的调用就需要使用轻量级的通信协议来实现，例如HTTP和RPC。</p><p>Docker：用户部署。微服务拆分成多个微服务，部署起来就很困难。</p><p>ELK：用于监控和日志管理。系统需要进行监控，进行日志管理，微服务一多监控和管理难起来了。</p><p>seata：用于分布式事务。微服务具有分布式系统的特性，带来了分布式系统典型的挑战，数据一致性的问题。</p><h2 id="单体服务"><a href="#单体服务" class="headerlink" title="单体服务"></a>单体服务</h2><p>单体服务：传统的软件架构风格，将整个应用程序作为一个<strong>单一的</strong>、<strong>紧耦合</strong>的单元进行开发的部署。</p><p>以下是单体架构的特点：</p><p><strong>单一代码库</strong>：所有功能模块共享一个代码块。</p><p><strong>集中式管理</strong>：所有功能模块共享同一个数据库和资源。</p><p><strong>部署简单</strong>：由于所有模块集成在一起，部署时只需一次操作即可完成。</p><p><strong>性能优化</strong>：由于所有模块都在一个进程中运行，模块之间的调用速度块。</p><p><img src="/2024/06/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/2-1717596379266-7.png"></p><p>优点：</p><p><strong>开发简单</strong> <strong>部署简单</strong> <strong>性能较好</strong></p><p>缺点：</p><p><strong>维护困难 扩展性差 部署风险高 技术栈单一</strong></p><h2 id="微服务流行框架"><a href="#微服务流行框架" class="headerlink" title="微服务流行框架"></a>微服务流行框架</h2><ol><li>Dubbo</li><li>Spring cloud Netfix</li><li>Spring Cloud Alibaba</li></ol><h2 id="微服务的组件"><a href="#微服务的组件" class="headerlink" title="微服务的组件"></a>微服务的组件</h2><ol><li>注册中心：用于服务的注册与发现，管理微服务的地址信息，常见的实现包括：<ol><li>Spring cloud Netflix：Eureka、Consul</li><li>Spring cloud Alibaba：Nacos</li></ol></li><li>配置中心：用于几种管理微服务的配置信息，可以动态修改配置而不需要重启服务。常见的实现包括：<ol><li>Spring cloud Netflix：Spring cloud Config</li><li>Spring cloud Alibaba：Nacos config</li></ol></li><li>远程调用：用于在不同的微服务之间进行通信和协作。常见的实现包括：<ol><li>RESRful API：如rest template 、Feign</li><li>RPC（远程过程调用）：如Dubbo、gRPC</li></ol></li><li>API网关：作为微服务架构的入口，统一暴露服务，并提供路由、负载均衡、安全认证等功能，常见的实现包括：<ol><li>Spring cloud Netflix：Zuul、Gateway</li><li>Springcloud Alibaba：Gateway、Apisix</li></ol></li><li>分布式事务：保证跨多个微服务的一致性和原子性操作，常见的实现包括：<ol><li>spring CLoud Alibaba：Seata</li></ol></li><li>熔断器：用于防止微服务之间的故障扩散，提高系统的容错能力。常见的实现包括：<ol><li>spring CLoud Netflix：Hystrix</li><li>Spring Cloud Alibaba：Sentinel</li></ol></li><li>限流和降级：用于防止微服务过载，对请求进行限制和降级处理，常见的实现包括：<ol><li>Spring Cloud Netflix：Hystrix</li><li>Spring cloud Alibaba：Sentinel</li></ol></li><li>分布式追踪和监控：用于跟踪和监控微服务的请求流程和性能指标。常见的实现包括：<ol><li>SpringCloud Netflix：Spring Cloud Sleuth + Zipkin</li><li>Spring Cloud Alibaba：SkyWalking、Sentinel Dashboard</li></ol></li></ol><h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><p><strong>服务注册</strong>：各个服务在启动时向注册中心注册自己的网络地址、服务实例信息和其他相关元数据。这样，其他服务就可以通过注册中心获取到当前可用的服务列表。</p><p><strong>服务发现</strong>：客户端通过向注册中心查询特定服务的注册中心，获得可用的服务实例列表。这样客户端就可以根据需要选择合适的服务进行调用。实现了服务间的解耦。</p><p><strong>负载均衡</strong>：决定了服务调用方如何选择一个服务实例进行调用。Ribbon是开源的客户端负载均衡器。常见的负载均衡策略包括：</p><p>​轮询：按顺序依次调用每个服务实例。</p><p>​随机：随机选择一个服务实例进行调用。</p><p>​权重轮询：根据服务实例的权重按顺序依次调用。使用于服务实例的性能茶几较大的情况。</p><p>​最小连接数：选择当前连接数最少的服务实例。</p><p>​一致性哈希：根据请求的某个属性进行哈希计算，选择特定的服务实例。可以确保相同的请求总是被路由到同一个服务实例，适用于需要会话粘性强的场景。如缓存服务、分布式数据库等。一致性哈希主要用于分布式系统中，以解决接待你动态加入和退出对系统负载均衡的影响。他通过将数据和节点映射到一个<strong>环形哈希空间</strong>来实现负载均衡。</p><p><strong>健康检查</strong>：确保健康的服务实例才能被其他服务发现和调用。Nacos支持多种健康检查机制，包括HTTP、TCP和自定义健康检查。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>首先一个服务发起RESTful格式的请求，会被spring cloud的拦截器拦截到，解析其请求路径，得到请求的服务名，请求的资源路径，然后通过负载均衡器根据获取到的服务名去注册中心拉取对应的服务列表，存储在对应的服务中。然后根据设置的负载均衡策略，去选择一个服务实例。修改原先的请求路径，发起真实的请求。</p><p><img src="/2024/06/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/3-1717596390213-9.png"></p><h3 id="Eruka的实现原理"><a href="#Eruka的实现原理" class="headerlink" title="Eruka的实现原理"></a>Eruka的实现原理</h3><p>Eureka的实现原理，大概可以从这几个方面来看：</p><p> 服务注册与发现: 当一个服务实例启动时，它会向Eureka Server发送注册请求，将自己的信息注册到注册中心。Eureka Server会将这些信息保存在内存中，并提供REST接口供其他服务查询。服务消费者可以通过查询服务实例列表来获取可用的服务提供者实例，从而实现服务的发现。 </p><p>服务健康检查: Eureka通过心跳机制来检测服务实例的健康状态。服务实例会定期向Eureka Server发送心跳，也就是续约，以表明自己的存活状态。如果Eureka Server在一定时间内没有收到某个服务实例的心跳，则会将其标记为不可用，并从服务列表中移除，下线实例。</p><p> 服务负载均衡: Eureka客户端在调用其他服务时，会从本地缓存中获取服务的注册信息。如果缓存中没有对应的信息，则会向Eureka Server发送查询请求。Eureka Server会返回一个可用的服务实例列表给客户端，客户端可以使用负载均衡算法选择其中一个进行调用。</p><h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><p>微服务架构中的每个服务通常需要一些配置信息，例如数据库连接地址、服务端口、日志级别等。这些配置可能因为不同环境、不同部署实例或者动态运行时需要进行调整和管理。微服务的实例一般非常多，如果每个实例都需要一个个地去做这些配置，那么运维成本将会非常大，这时候就需要一个集中化地配置中心，去管理这些配置。</p><p>为什么需要有配置中心？？<strong>集中管理、动态更新配置、多环境配置、配置的版本管理、安全性和访问控制</strong></p><p>配置中心用于<strong>集中管理</strong>和分发配置，配置中心可以帮助你在<strong>多个环境（开发、测试、生产）中管理</strong>配置，并支持<strong>动态更新配置</strong>，从而提高系统的可维护性。</p><h3 id="配置中心的原理"><a href="#配置中心的原理" class="headerlink" title="配置中心的原理"></a>配置中心的原理</h3><p>一句话：<strong>配置信息的CRUD</strong>。</p><p>具体的实现大概可以分成这么几个部分： </p><p><strong>配置信息存储</strong>：Nacos默认使用内嵌数据库Derby来存储配置信息，还可以采用MySQL等关系型数据库。</p><p> <strong>注册配置信息</strong>：服务启动时，Nacos Client会向Nacos Server注册自己的配置信息，这个注册过程就是把配置信息写入存储，并生成版本号。 </p><p><strong>获取配置信息</strong>：服务运行期间，Nacos Client通过API从Nacos Server获取配置信息。Server根据键查找对应的配置信息，并返回给Client。</p><p> <strong>监听配置变化</strong>：Nacos Client可以通过注册监听器的方式，实现对配置信息的监听。当配置信息发生变化时，Nacos Server会通知已注册的监听器，并触发相应的回调方法。</p><p><img src="/2024/06/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20240604213217136.png" alt="image-20240604213217136"></p><p>Nacos的在pull的基础上，采用了长轮询来进行配置的动态刷新。在长轮询模式下，客户端定时向服务端发起请求，检查配置信息是否发生变更。如果没有发生变更，服务端会“hold”这个请求，即暂时不返回结果，知道配置发生变化或者达到一定的超时时间。是通过设置一个定时任务来完成的。这种方式可以即使获取最新的配置信息，同时也降低了服务端的压力，避免了大量的长连接占用内存资源。</p><h3 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h3><h3 id="配置共享"><a href="#配置共享" class="headerlink" title="配置共享"></a>配置共享</h3><h2 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h2><h3 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h3><p>Feign是一个<strong>声明式</strong>的Web服务<strong>客户端</strong>，他简化了使用基于HTTP的远程服务的开发。Feign是在RestTemplate和Ribbon的基础上，进一步封装，<strong>使用RestTemplate实现Http的调用，使用Ribbon实现负载均衡</strong>。</p><p><strong>声明式API</strong>：Feign允许开发者使用简单的注解来定义和描述对远程服务的访问。通过使用注解，开发者可以轻松地指定URL、HTTP方法，请求参数，请求头等信息，使用远程调用变得非常直观和易于理解。</p><p><strong>使用过程：</strong></p><p>导入相应依赖，openFeign依赖。</p><p>启用Feign客户端（调用方），注解是@EableFeignClient，</p><p>定义Feign客户端接口（调用方）,注解是@FeignClient(name&#x3D;’server-name’)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = &quot;remote-service&quot;)</span> <span class="hljs-comment">// 指定要调用的服务名称</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RemoteServiceClient</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/api/endpoint/&#123;id&#125;&quot;)</span><br>    String <span class="hljs-title function_">getEndpoint</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> String id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用Feign客户端，在服务中注入并使用Feign客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RemoteServiceClient remoteServiceClient;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">callRemoteService</span><span class="hljs-params">(String id)</span> &#123;<br>        <span class="hljs-keyword">return</span> remoteServiceClient.getEndpoint(id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Feign实现认证传递"><a href="#Feign实现认证传递" class="headerlink" title="Feign实现认证传递"></a>Feign实现认证传递</h3><p>首先，Feign提供了一个拦截器的功能，允许在请求发送前后进行自定义处理。这对于<strong>添加认证信息、日志记录、修改请求参数</strong>等非常有用。Feign提供了<strong>RequestInterceptor接口</strong>，可以通过实现这个接口来定义自定义的拦截逻辑。</p><p>Feign拦截又分为局部拦截和全局拦截。两者的区别就是是否在拦截器上添加注解@configuration。局部拦截则是在对应的FeignClient添加对应的拦截器。</p><p><strong>在请求头中添加认证信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> feign.RequestInterceptor;<br><span class="hljs-keyword">import</span> feign.RequestTemplate;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FeignConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RequestInterceptor <span class="hljs-title function_">requestInterceptor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInterceptor</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(RequestTemplate template)</span> &#123;<br>                <span class="hljs-comment">// 在请求头中添加认证信息</span><br>                template.header(<span class="hljs-string">&quot;Authorization&quot;</span>, <span class="hljs-string">&quot;Bearer &quot;</span> + getToken());<br>            &#125;<br><br>            <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getToken</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-comment">// 获取认证令牌的逻辑，例如从安全上下文中获取</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;your-token&quot;</span>;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实现日志记录和自定义参数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> feign.RequestInterceptor;<br><span class="hljs-keyword">import</span> feign.RequestTemplate;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FeignConfig</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(FeignConfig.class);<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RequestInterceptor <span class="hljs-title function_">requestInterceptor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInterceptor</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(RequestTemplate template)</span> &#123;<br>                <span class="hljs-comment">// 添加日志记录</span><br>                logger.info(<span class="hljs-string">&quot;Feign request to: &quot;</span> + template.url());<br><br>                <span class="hljs-comment">// 添加自定义请求参数</span><br>                template.query(<span class="hljs-string">&quot;customParam&quot;</span>, <span class="hljs-string">&quot;customValue&quot;</span>);<br><br>                <span class="hljs-comment">// 在请求头中添加认证信息</span><br>                template.header(<span class="hljs-string">&quot;Authorization&quot;</span>, <span class="hljs-string">&quot;Bearer &quot;</span> + getToken());<br>            &#125;<br><br>            <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getToken</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-comment">// 获取认证令牌的逻辑，例如从安全上下文中获取</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;your-token&quot;</span>;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="服务容灾"><a href="#服务容灾" class="headerlink" title="服务容灾"></a>服务容灾</h2><h3 id="什么是服务雪崩"><a href="#什么是服务雪崩" class="headerlink" title="什么是服务雪崩"></a>什么是服务雪崩</h3><p>微服务架构中，由于一个服务的故障或者性能问题，依赖的服务还在不断发起请求，或者重试，那么请求的压力会不断的在下游堆积，导致依赖该服务的其他服务也出现故障，进而引发级联式的服务故障。最终导致整个系统的崩溃。</p><p>为了防止服务雪崩，可以采用这些措施：</p><p><strong>服务高可用部署</strong>：确保各个服务都具备高可用性，通过冗余部署、故障转移等方式来减少单点故障的影响。</p><p><strong>限流和熔断</strong>：对服务之间的请求进行限流和熔断，以防止过多的请求涌入导致后端服务不可用。</p><p><strong>缓存和降级</strong>：合理利用缓存来减轻后端服务的负载压力，并在必要时进行服务降级，保证核心功能的可用性。</p><h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>服务熔断是微服务架构中的容错机制，用于保护系统免受服务故障或异常的影响。当某个服务出现故障或异常时，服务熔断可以快速隔离该服务，确保系统稳定可用。 </p><p>它通过监控服务的调用情况，当错误率或响应时间超过阈值时，触发熔断机制，后续请求将返回默认值或错误信息，避免资源浪费和系统崩溃。 </p><p>服务熔断还支持自动恢复，重新尝试对故障服务的请求，确保服务恢复正常后继续使用。</p><h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>服务降级是也是一种微服务架构中的容错机制，用于在系统资源紧张或服务故障时保证核心功能的可用性。 </p><p>当系统出现异常情况时，服务降级会主动屏蔽一些非核心或可选的功能，而只提供最基本的功能，以确保系统的稳定运行。</p><p>通过减少对资源的依赖，服务降级可以保证系统的可用性和性能。 </p><p>它可以根据业务需求和系统状况来制定策略，例如替换耗时操作、返回默认响应、返回静态错误页面等。</p><h3 id="Sentinel怎么实现限流的"><a href="#Sentinel怎么实现限流的" class="headerlink" title="Sentinel怎么实现限流的"></a>Sentinel怎么实现限流的</h3><p>Sentinel式Alibaba开源的一款流量防护组件，主要用于分布式系统中的流量控制、熔断降级和系统负载保护。Sentinel提供了丰富的限流功能，可以帮助开发者在高并发的场景下保护系统的稳定性和可靠性。</p><p>步骤：</p><ol><li>引入依赖</li><li>配置Sentinel</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">transport:</span><br>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span><br>        <span class="hljs-attr">port:</span> <span class="hljs-number">8719</span><br></code></pre></td></tr></table></figure><ol start="3"><li><p>启用Sentinel</p></li><li><p>定义限流规则和降级处理逻辑</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>    <span class="hljs-meta">@SentinelResource(value = &quot;callRemoteService&quot;, blockHandler = &quot;blockHandlerMethod&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">callRemoteService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://remote-service/api/endpoint&quot;</span>;<br>        <span class="hljs-keyword">return</span> restTemplate.getForObject(url, String.class);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">blockHandlerMethod</span><span class="hljs-params">(Throwable ex)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Blocked by Sentinel: &quot;</span> + ex.getClass().getSimpleName();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>配置限流规则</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SentinelConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CommandLineRunner</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(String... args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        initFlowRules();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initFlowRules</span><span class="hljs-params">()</span> &#123;<br>        List&lt;FlowRule&gt; rules = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">FlowRule</span> <span class="hljs-variable">rule</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowRule</span>();<br>        rule.setResource(<span class="hljs-string">&quot;callRemoteService&quot;</span>);<br>        rule.setGrade(RuleConstant.FLOW_GRADE_QPS);<br>        rule.setCount(<span class="hljs-number">1</span>); <span class="hljs-comment">// QPS 限制为 1</span><br>        rules.add(rule);<br>        FlowRuleManager.loadRules(rules);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li>使用Sentinel控制台配置限流规则</li></ol><h2 id="API网关"><a href="#API网关" class="headerlink" title="API网关"></a>API网关</h2><p>API网关是一种中间层服务器，用于集中管理、保护和路由对后端服务的访问。它充当了客户端与后端服务之间的入口点。提供了一组统一的接口来管理和控制API的访问。</p><p>API网关的主要功能包括：</p><ol><li><strong>路由转发</strong>：API网关根据请求的URL路径或其他标识，将请求路由到相应的后端服务。通过配置路由规则，可以灵活地将请求分发给不同地后端服务。</li><li><strong>负载均衡</strong>：API网关可以在后端服务之间实现负载均衡，将请求平均分发到多个实例上，提高系统的吞吐量和可扩展性。</li><li><strong>安全认证与授权</strong>：API网关可以集中处理身份认证和授权，确保只有经过身份认证的客户端才能访问后端服务。他可以与身份提供者（如Oatuh）集成，进行用户认证和授权操作。</li><li></li></ol><h3 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a>Spring Cloud Gateway</h3><p>一个基于Spring WebFlux构建的API网关，提供了动态路由、过滤器、负载均衡等功能。</p><p><strong>引用：路人张的面试笔记 <a href="http://www.mianshi.online/">www.mianshi.online</a></strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaLearning528</title>
    <link href="/2024/05/28/JavaLearning528/"/>
    <url>/2024/05/28/JavaLearning528/</url>
    
    <content type="html"><![CDATA[<h3 id="java注意事项"><a href="#java注意事项" class="headerlink" title="java注意事项"></a>java注意事项</h3><ol><li>接口可以声明变量，但默认是public static final修饰。即接口不可声明实例变量，该变量也不可修改。遵循基本的Queu接口约定。是一个非阻塞队列，不允许null元素，线程不安全。常用于按特定顺序处理元素的场景，例如任务调度、Dijkstra最短路径算法、贪心算法等。</li><li>priorityQueue：一个基于优先级堆的无界优先队列。继承自AbstractQueue类并实现了Queue接口。</li><li>transient修饰符：用于修饰表示该成员变量不可被序列化用于网络传输，例如password。不能用于修饰布局变量。</li><li>Java中的静态方法不能被覆盖（override）。java的private修饰的方法不能被覆盖。</li><li>当子类覆盖（override）父类的方法时，确实可以修改方法的访问修饰符，但这种修改是受限制的。子类覆盖的方法不能拥有比父类方法更严格的访问级别。这意味着，子类可以增加访问权限，但不能减少访问权限。</li><li>构造函数可以抛出异常</li><li>yield()方法：<code>yield()</code> 方法是 <code>Thread</code> 类的一个静态方法，它的作用是给线程调度器（Thread Scheduler）一个暗示，表明当前线程愿意放弃其当前的时间片段，让其他线程有机会执行。然而，这只是一个暗示，并不能保证会产生任何影响。具体的行为取决于底层的线程调度器和操作系统的实现。</li><li>Integer.praseInt(String s,int radix)的实现原理：首先会判断待转换的s的首位字符是否为“0”或者“ - ”或者“ + ”或者是其他非法的字符，并做不同的处理。然后通过while循环依次从左往后将原来的result乘以进制减去对应下标的值，【为什么是减而不是加，是因为<code>Integer.MIN_VALUE</code> 的绝对值比 <code>Integer.MAX_VALUE</code> 大1（Java中 <code>Integer.MIN_VALUE</code> 是 <code>-2^31</code>，而 <code>Integer.MAX_VALUE</code> 是 <code>2^31 - 1</code>）如果在正数空间进行累积，那么在处理极限值的情况下可能无法正确表示 <code>-Integer.MIN_VALUE</code>。通过在负数空间进行累积，我们可以确保即使是 <code>-Integer.MIN_VALUE</code> 这样的值也能被正确处理。】最后根据判断得到的“ +” 还是“ - ”进行是否取反的操作。具体源码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">parseInt</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> radix)</span><br>                <span class="hljs-keyword">throws</span> NumberFormatException<br>    &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * WARNING: This method may be invoked early during VM initialization</span><br><span class="hljs-comment">         * before IntegerCache is initialized. Care must be taken to not use</span><br><span class="hljs-comment">         * the valueOf method.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberFormatException</span>(<span class="hljs-string">&quot;null&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (radix &lt; Character.MIN_RADIX) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberFormatException</span>(<span class="hljs-string">&quot;radix &quot;</span> + radix +<br>                                            <span class="hljs-string">&quot; less than Character.MIN_RADIX&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (radix &gt; Character.MAX_RADIX) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberFormatException</span>(<span class="hljs-string">&quot;radix &quot;</span> + radix +<br>                                            <span class="hljs-string">&quot; greater than Character.MAX_RADIX&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">negative</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, len = s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">limit</span> <span class="hljs-operator">=</span> -Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> multmin;<br>        <span class="hljs-type">int</span> digit;<br><br>        <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">firstChar</span> <span class="hljs-operator">=</span> s.charAt(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (firstChar &lt; <span class="hljs-string">&#x27;0&#x27;</span>) &#123; <span class="hljs-comment">// Possible leading &quot;+&quot; or &quot;-&quot;</span><br>                <span class="hljs-keyword">if</span> (firstChar == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                    negative = <span class="hljs-literal">true</span>;<br>                    limit = Integer.MIN_VALUE;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstChar != <span class="hljs-string">&#x27;+&#x27;</span>)<br>                    <span class="hljs-keyword">throw</span> NumberFormatException.forInputString(s);<br><br>                <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) <span class="hljs-comment">// Cannot have lone &quot;+&quot; or &quot;-&quot;</span><br>                    <span class="hljs-keyword">throw</span> NumberFormatException.forInputString(s);<br>                i++;<br>            &#125;<br>            multmin = limit / radix;<br>            <span class="hljs-keyword">while</span> (i &lt; len) &#123;<br>                <span class="hljs-comment">// Accumulating negatively avoids surprises near MAX_VALUE</span><br>                digit = Character.digit(s.charAt(i++),radix);<br>                <span class="hljs-keyword">if</span> (digit &lt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">throw</span> NumberFormatException.forInputString(s);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (result &lt; multmin) &#123;<br>                    <span class="hljs-keyword">throw</span> NumberFormatException.forInputString(s);<br>                &#125;<br>                result *= radix;<br>                <span class="hljs-keyword">if</span> (result &lt; limit + digit) &#123;<br>                    <span class="hljs-keyword">throw</span> NumberFormatException.forInputString(s);<br>                &#125;<br>                result -= digit;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> NumberFormatException.forInputString(s);<br>        &#125;<br>        <span class="hljs-keyword">return</span> negative ? result : -result;<br>    &#125;<br></code></pre></td></tr></table></figure><ol start="9"><li>Arrays的常用方法<ol><li>Arrays.toString(int[] arr)：用于将数组以字符串的形式展示</li><li>Arrays.stream(int[] arr)：用于将数组转换为流模式，以便下次操作</li><li>Arrays.sort(int[] arr)：用于数组排序，默认采用快速排序</li><li>Arrays.asList(T… a)：用于将数组转换为列表，内部实现即通过创建一个ArrayList并传入参数。</li><li>Arrays.fill(int[] a,nt value)：用于填充目标数组。</li><li>Arrays.copyOf(int[] source,int newlength)：用于扩充数组，在ArrayList的底层的扩容机制就是用到该方法。</li><li>Arrays.equals(int[] arr1,int[] arr2)：用于比较两数组的值是否相同</li></ol></li><li>assert关键字：用于创建断言语句，用于在测试期间验证程序的假设，以确保代码的关键部分按预期方法工作。如果一个断言失败，呢么程序将抛出一个AssertionError异常。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">assert</span> expression1;<br><span class="hljs-keyword">assert</span> expression1 : expression2;<br><br><span class="hljs-keyword">assert</span> value == <span class="hljs-number">3</span> : <span class="hljs-string">&quot;Value should be 3&quot;</span>;<br></code></pre></td></tr></table></figure><ol start="11"><li><p>Java的接口可以有默认实现方法，使用defalut关键字进行修饰。普通的接口方法默认的修饰符是public。方法也可以修饰为private和static。</p></li><li><p>IntStream的使用：<code>IntStream</code>是一个专门用于处理原始<code>int</code>类型数据的流。它提供了一套针对数字操作的特定方法，如<code>sum()</code>、<code>average()</code>、<code>max()</code>、<code>min()</code>等，这些方法直接适用于原始<code>int</code>类型的值。<code>IntStream</code>在处理原始类型数据时比<code>Stream&lt;Integer&gt;</code>更加高效。</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MyBatisLearning</title>
    <link href="/2024/05/26/MyBatisLearning/"/>
    <url>/2024/05/26/MyBatisLearning/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="Mybatis的基本理解"><a href="#Mybatis的基本理解" class="headerlink" title="Mybatis的基本理解"></a>Mybatis的基本理解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//加载mybatis的核心配置文件，里头包含环境配置即SQL连接信息和Mybatis的映射文件位置</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br><span class="hljs-comment">//创建ssfb</span><br><span class="hljs-type">SqlSessionFactoryBuilder</span> <span class="hljs-variable">ssfb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>();<br><span class="hljs-comment">//工厂模式：将我们创建对象的过程进行封装，直接提供想要的对象</span><br><span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">ssf</span> <span class="hljs-operator">=</span> ssfb.build(is);<br><span class="hljs-comment">//创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交</span><br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> ssf.openSession(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">//代理模式，UserMapper只是一个接口，使用的是JDK代理模式，返回一个接口的代理对象，代理对象proxyh会拦截接口方法，转而进行MappedStatement所代表的sql，然后将sql执行结果返回。</span><br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">usermapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br></code></pre></td></tr></table></figure><h2 id="Mybatis的执行过程"><a href="#Mybatis的执行过程" class="headerlink" title="Mybatis的执行过程"></a>Mybatis的执行过程</h2><p>Mybatis是一个半自动的ORM框架。ORM就是object relationalmapping，object就是java的对象，relational就是关系，也就是关系数据库的数据。所以就是数据库表的一行数据和Java的对象实例的映射。Mybatis是一个框架，框架就是对原始的东西进行一个封装和提出一些规则的限制。在java中原始操作数据库的API就是JDBC。在使用JDBC时，需要设置数据库的相关信息，数据库Driver，ip，port，数据库，用户，密码等信息，然后创建连接，也就是getConnection，返回一个connection对象。再编写对应的SQL语句，可以是静态的，也可以是预编译的，动态传入参数。再执行相应的SQL语句，返回resultSet结果。然后对结果进行分析将其转换为Java的pojo对象。</p><p>Mybatis就是对JDBC的创建连接、执行SQL语句，解析并封装结果等过程进行了封装。</p><p><strong>初始化阶段</strong>：在使用Mybatis时会有一个Mybatis.config.xml的配置文件，里头会有一些基础信息，如数据库环境信息，Mapper的信息，类型别名的信息等等。Mybatis提供一个SqlSessionFactoryBuilder类通过build方法可以对配置信息进行解析和封装成一个Configuration对象并得到对应的SqlSessionFactory。再通过SqlSessionFactory得到SqlSession。在这个过程中，Configuration对象通过责任链模式在这几个对象之间传递。</p><p><strong>执行阶段</strong>：Mybatis提供了多种类型的Executor，例如有CacheExecutor、BaseExecutor和SimpleExecutor。获得对应的SqlSession后执行增删改查操作时实际上是交给对应的Executor进行处理。首先会交给CachingExecutor进行判断是否开启二级缓存，未开启的话则交由委托的Executor执行，接着会进入到BaseExecutor的query方法，查看是否具有一级缓存，没有的话则会交给SimpleExecutor去执行doQuery方法，然后交给StatementHandler去处理SQL语句，再交由给参数处理器ParameterHandler解析SQL参数，并基于参数映射，填充至PreparedStatement，，最总交给结果集处理器ResultSetHandler，用于读取ResultSet结果集，并基于结果集映射，封装成Java对象。</p><p><img src="/2024/05/26/MyBatisLearning/1.png"></p><h2 id="Mybatis的四大组件"><a href="#Mybatis的四大组件" class="headerlink" title="Mybatis的四大组件"></a>Mybatis的四大组件</h2><ol><li><strong>执行器：</strong>Executor, 处理流程的头部，主要负责缓存、事务、批处理。一个执行可用于执行多条SQL。它和SQL处理器是1对N的关系。</li><li><strong>Sql处理器：</strong>StatementHandler 用于和JDBC打道，比如基于SQL声明Statement、设置参数、然后就是调用Statement来执行。它只能用于一次SQL的执行</li><li><strong>参数处理器：</strong>ParameterHandler，用于解析SQL参数，并基于参数映射，填充至PrepareStatement。同样它只能用于一次SQL的执行</li><li><strong>结果集处理器：</strong>ResultSetHandler，用于读取ResultSet 结果集，并基于结果集映射，封装成JAVA对象。他也只用用于一次SQL的执行。</li></ol><p><img src="/2024/05/26/MyBatisLearning/2.png"></p><p>mybatis中接口是怎么找到对应的xml文件的？</p><h2 id="Mybatis的设计模式"><a href="#Mybatis的设计模式" class="headerlink" title="Mybatis的设计模式"></a>Mybatis的设计模式</h2><ol><li>工厂模式</li><li>建造者模式</li><li>代理模式</li></ol><h2 id="Mybatis的xml写法"><a href="#Mybatis的xml写法" class="headerlink" title="Mybatis的xml写法"></a>Mybatis的xml写法</h2><ol><li><strong>增删改</strong>操作比较简单，往往不需要接收返回参数，相应的标签为 insert delete update</li><li><strong>查询</strong>则会有返回参数这时候需要ORM，即对象和关系之间的映射，即需要指定resultType或者resultMap。Mybatis会帮助我们完成ORM，但是我们需要指定要映射成的对象是什么，所以Mybatis也被称为是半自动的ORM框架。在使用JDBC时，通常是需要自己处理对象和关系之间的映射的。相应的标签是 select。</li><li><strong>JDBC</strong>：是Java提供的一个操作数据库的API。需要指定SQL驱动、数据库地址、用户名和密码信息。以下是一个代码片段</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-type">int</span> userId)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//创建对应的预定义的statement</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SELECT id, username, email FROM users WHERE id = ?&quot;</span>;<br>    <span class="hljs-comment">//创建连接，赋preSQl语句</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> getConnection();<br>             <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql)) &#123;<br>            <span class="hljs-comment">//赋值，并执行SQL语句</span><br>            stmt.setInt(<span class="hljs-number">1</span>, userId);<br>            <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> stmt.executeQuery();<br><span class="hljs-comment">//ORM操作，这就是Mybatis框架剩下的操作</span><br>            <span class="hljs-keyword">if</span> (rs.next()) &#123;<br>                user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>                user.setId(rs.getInt(<span class="hljs-string">&quot;id&quot;</span>));<br>                user.setUsername(rs.getString(<span class="hljs-string">&quot;username&quot;</span>));<br>                user.setEmail(rs.getString(<span class="hljs-string">&quot;email&quot;</span>));<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            <span class="hljs-comment">// 处理 JDBC 错误</span><br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="获取方法的参数"><a href="#获取方法的参数" class="headerlink" title="获取方法的参数"></a>获取方法的参数</h2><ol><li><strong>参数只有一个时：</strong><ol><li>使用**$**：该符号原属于properties文件的展位号，也可以用于xml，表示字符串的拼接。当方法传递的参数是字符串或者日期时，MySQL语句在查询时是需要加上单或者双引号的（where username&#x3D; “lihua”)。</li><li>使用**#**：本质是占位符赋值。本质上实现进行statement的拼接成对应的statement，然后执行SQL语句。所以使用#号需要拼接(where username &#x3D; ‘${username}’) 。本质上是通过将#{}转换为？，然后创建对应的preparedStatement，然后调用对应的set方法对prepareStatement进行赋值，然后执行SQL语句。</li></ol></li><li><strong>参数有多个时</strong>：<ol><li>常用方式是通过注解 @param进行相对应</li><li>传递的参数是一个实体时，直接使用该实体的成员变量就行</li><li>使用Map传递参数，直接使用该Map的key值就行</li></ol></li></ol><h2 id="获取查询的结果"><a href="#获取查询的结果" class="headerlink" title="获取查询的结果"></a>获取查询的结果</h2><ol><li><strong>当结果只有一条记录时</strong>：<ol><li>直接通过实体类进行接收</li><li>可以通过list集合接收</li></ol></li><li><strong>当结果有多条记录时</strong>：<ol><li>使用List&lt;&gt;进行接收</li></ol></li><li><strong>当结果为聚合函数结果时</strong>：<ol><li>有其映射关系 ：java.lang.Integer –&gt; int,integer int –&gt; _int,_integer Map –&gt; map String –&gt; string</li></ol></li></ol><h2 id="特殊查询"><a href="#特殊查询" class="headerlink" title="特殊查询"></a>特殊查询</h2><ol><li><strong>模糊查询</strong>：如<code>where username = ‘%hua%’</code>，在xml编写时传递参数值时使用$，<code>where username = ‘%$&#123;username&#125;%’</code>,而不可使用#。</li><li><strong>批量删除</strong>：传递的参数列表使用逗号分隔时，如<code>ids = 1，2，3，4</code>，则需要使用$，如<code>where id in ($&#123;ids&#125;)</code>。</li><li><strong>动态设置表名</strong>：SQL语句中表名一般不带引号。一些特殊的表名则需要添加反引号区分。例如User表，这就是反引号 &#96; 。</li></ol><h2 id="获取自增的主键"><a href="#获取自增的主键" class="headerlink" title="获取自增的主键"></a>获取自增的主键</h2><ol><li>JDBC 实现的时候有一个方法 <code>ResultSet resultSet = ps.getGeneratedKeys();</code>MyBatis中通过在 mapper 映射文件中设置 <code>useGeneratedKeys=&quot;true&quot;</code> 属性</li></ol><h2 id="ResultMap"><a href="#ResultMap" class="headerlink" title="ResultMap"></a>ResultMap</h2><ol><li><p><strong>resultMap</strong>：用于处理属性和字段的映射关系，解决映射关系时课通过在select语句给字段起别名，也可使用resultMap。resultMap标签有属性id（标识该resultMap） 和type（返回的pojo实体类），子标签有id和property，id标签用于设置主键的映射关系，property用于设置普通字段的映射关系。这两个标签有property（实体属性）和column（数据库表字段）这个属性，用于映射。</p></li><li><p>多对一的情况</p><ol><li>级联赋值</li><li>association标签</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml">`<span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userProfileMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;UserProfile&quot;</span>&gt;</span>     <br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> /&gt;</span>     <br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;phone&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;phone&quot;</span> /&gt;</span>     <br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;address&quot;</span> /&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> /&gt;</span>     <br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span> /&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;profile&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userProfileMap&quot;</span> /&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserWithProfile&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userMap&quot;</span>&gt;</span>    <br>    SELECT u.id AS user_id, u.username, p.*     FROM users u     LEFT JOIN user_profiles p ON u.id = p.user_id     WHERE u.id = #&#123;id&#125; <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>`<br><br></code></pre></td></tr></table></figure></li></ol><h2 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h2><p>关联对象查询，有两种实现方式，</p><p>一种是单独发送一个 sql 去查询关联对象，赋给主对象，然后返回主对象。好处是</p><p>另一种是使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql 查询，就可以把主对象和其关联对象查出来。</p><h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><ol><li>一对一查询，是指一个对象与另一个对象之间存在一对一的关系。例如一个用户有一个地址信息。通常通过 <code>resultMap</code> 以及相关的标签（如 <code>&lt;association&gt;</code> 和 <code>&lt;collection&gt;</code>）来实现。例子如下：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.example.domain.User&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;email&quot;</span>/&gt;</span><br>        <br>        #这里<br>        <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;com.example.domain.Address&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;address_id&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;street&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;street&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;city&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;city&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;state&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;state&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;zip&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;zip&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br>        <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserWithAddress&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userResultMap&quot;</span>&gt;</span><br>        SELECT u.*, a.* <br>        FROM users u <br>        LEFT JOIN addresses a ON u.address_id = a.id <br>        WHERE u.id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ol start="2"><li>一对多关联查询，是指一个对象与多个对象之间存在一对多的关系，例如一个用户有多个订单。实现方式：<strong>使用 <code>&lt;collection&gt;</code> 标签</strong>：在 <code>resultMap</code> 中使用 <code>&lt;collection&gt;</code> 标签来定义一对多的关联关系。例子如下：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.example.domain.User&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;email&quot;</span>/&gt;</span><br>        <br>        # 这里<br>        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orders&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;com.example.domain.Order&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_id&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderDate&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_date&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;amount&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;amount&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br>        <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserWithOrders&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userResultMap&quot;</span>&gt;</span><br>        SELECT u.*, o.id as order_id, o.order_date, o.amount <br>        FROM users u <br>        LEFT JOIN orders o ON u.id = o.user_id <br>        WHERE u.id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="分步查询"><a href="#分步查询" class="headerlink" title="分步查询"></a>分步查询</h3><p><strong>一对一、多对一的查询</strong></p><ol><li><p><strong>分步查询的第一步</strong>：先根据员工 id 获取员工的信息</p><p><img src="/2024/05/26/MyBatisLearning/8.png"></p><p><strong>分步查询的第二步</strong>：通过部门 id 获取部门信息（有没有发现这个方法就算不作为分步查询的第二步，也可以作为根据部门 id 查询部门信息的一个方法）</p><p><img src="/2024/05/26/MyBatisLearning/9.png"></p><p>那么在 Emp 的映射文件中如何将两步查询到的信息关联起来呢，只能根据部门 id </p><p><img src="/2024/05/26/MyBatisLearning/3.png"></p><p>解释：</p><ul><li>association 标签中的 column 属性就将两个查询到的信息关联了起来；</li><li>select 属性中写的是 mapper 接口的全类名（<strong>唯一标识</strong>）；</li></ul></li></ol><p><strong>一对多、多对多的查询</strong></p><ol><li><strong>分步查询的第一步</strong>：先根据部门 id 获取部门的信息</li></ol><p><img src="/2024/05/26/MyBatisLearning/5.png"></p><p>解释：</p><ul><li><code>column</code>：分步查询条件。</li></ul><ol start="2"><li><strong>分步查询的第二步</strong>：通过部门 id 去员工表中查询所有的员工信息</li></ol><p><img src="/2024/05/26/MyBatisLearning/6.png"></p><h2 id="Mybatis的延迟加载"><a href="#Mybatis的延迟加载" class="headerlink" title="Mybatis的延迟加载"></a>Mybatis的延迟加载</h2><p>它的原理是，使用 <code>CGLIB</code> 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 <code>a.getB().getName()</code> ，拦截器 <code>invoke()</code> 方法发现 <code>a.getB()</code> 是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 <code>a.getB().getName()</code> 方法的调用。这就是延迟加载的基本原理。</p><p>例子如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.example.domain.User&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;email&quot;</span>/&gt;</span><br>        <br>        <span class="hljs-comment">&lt;!-- 配置一对一的延迟加载 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;com.example.domain.Address&quot;</span> <span class="hljs-attr">fetchType</span>=<span class="hljs-string">&quot;lazy&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;address_id&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;street&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;street&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;city&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;city&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br>        <br>        <span class="hljs-comment">&lt;!-- 配置一对多的延迟加载 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orders&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;com.example.domain.Order&quot;</span> <span class="hljs-attr">fetchType</span>=<span class="hljs-string">&quot;lazy&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_id&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderDate&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_date&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;amount&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;amount&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userResultMap&quot;</span>&gt;</span><br>        SELECT u.*, a.id AS address_id, a.street, a.city, o.id AS order_id, o.order_date, o.amount<br>        FROM users u<br>        LEFT JOIN addresses a ON u.address_id = a.id<br>        LEFT JOIN orders o ON u.id = o.user_id<br>        WHERE u.id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserService</span><span class="hljs-params">(UserMapper userMapper)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userMapper = userMapper;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-type">int</span> userId)</span> &#123;<br>        <span class="hljs-comment">// 查询用户信息，不会加载关联对象</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMapper.selectUserById(userId);<br>        <br>        <span class="hljs-comment">// 访问关联的地址对象时，才会触发延迟加载，执行查询</span><br>        <span class="hljs-type">Address</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> user.getAddress();<br>        <br>        <span class="hljs-comment">// 访问关联的订单集合时，才会触发延迟加载，执行查询</span><br>        List&lt;Order&gt; orders = user.getOrders();<br>        <br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><h2 id="Mybatis缓存"><a href="#Mybatis缓存" class="headerlink" title="Mybatis缓存"></a>Mybatis缓存</h2><ol><li><strong>一级缓存</strong>：同一个sqlSession执行同样的SQL语句时，会将第二次的结果缓存到对应的sqlSession中。不同的sqlSession对应的缓存也不同，对应的sqlSession会有一个map集合，用来存储查询结果。一级缓存失效的原因：两次查询之间进行了增删改操作，会自动清空缓存。</li><li><strong>二级缓存</strong>：同一个sqlSessionFactorty级别的缓存，需要通过配置来开启该功能。sqlSession关闭之后一级缓存会写入到二级缓存。</li></ol><h2 id="Mybatis的插件"><a href="#Mybatis的插件" class="headerlink" title="Mybatis的插件"></a>Mybatis的插件</h2><p>Mybatis的插件是通过动态dialing机制实现的。Mybatis定义了一个Interceptor接口，通过实现这个接口并定义相应的拦截逻辑，可以在执行Mybatis操作（如执行SQL、参数处理等）的关键点插入自定义的行为，Mybatis插件可以拦截四种类型的接口：</p><ol><li>Executor：负责SQL语句的执行和事务管理。</li><li>ParameterHandler：负责预处理语句（PreparedStatement）中占位符的参数设置。</li><li>ResultSetHandler：负责将JDBC查询结果集转换为Java对象。</li><li>StatementHandler：负责准备和执行预处理语句（preparedStatement）。</li></ol><h2 id="实现MyBatis插件的步骤"><a href="#实现MyBatis插件的步骤" class="headerlink" title="实现MyBatis插件的步骤"></a>实现MyBatis插件的步骤</h2><ol><li><strong>实现Interceptor接口</strong>：创建一个类实现Mybatis的Interceptor接口，并实现接口中的intercept方法，该方法就是拦截逻辑。</li><li><strong>使用@Intercepts注解</strong>：在插件类上使用@Intercepts注解来指定该插件将拦截哪些操作。在注解内部，使用@signatur注解来指定具体要拦截的接口、方法以及参数类型。</li><li><strong>配置插件</strong>：在Mybatis的配置文件中注册插件。</li></ol><p>一个简单的插件示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//2.使用@intercepts注解</span><br><span class="hljs-meta">@Intercepts(&#123;</span><br><span class="hljs-meta">    @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-comment">//1.1实现Interceptor接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExamplePlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">//1.2实现拦截逻辑</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;Before query&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> invocation.proceed(); <span class="hljs-comment">// 继续执行被拦截的方法</span><br>        System.out.println(<span class="hljs-string">&quot;After query&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">plugin</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-keyword">return</span> Plugin.wrap(target, <span class="hljs-built_in">this</span>); <span class="hljs-comment">// 使用 MyBatis 提供的 Plugin.wrap 方法来创建动态代理</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProperties</span><span class="hljs-params">(Properties properties)</span> &#123;<br>        <span class="hljs-comment">// 可以通过配置文件传递参数给插件</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;com.example.ExamplePlugin&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 这里可以配置插件属性 --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Mybatis的分页插件PageHelper的原理"><a href="#Mybatis的分页插件PageHelper的原理" class="headerlink" title="Mybatis的分页插件PageHelper的原理"></a>Mybatis的分页插件PageHelper的原理</h2><p>PageHelper也是Mybatis的插件，对指定的方法进行拦截，PageHelper拦截的方法是Executor组件的query方法，然后使用动态代理进行对SQL语句的重写，也就是对应的intercept方法。具体的拦截器源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The MIT License (MIT)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Copyright (c) 2014-2017 abel533@gmail.com</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Permission is hereby granted, free of charge, to any person obtaining a copy</span><br><span class="hljs-comment"> * of this software and associated documentation files (the &quot;Software&quot;), to deal</span><br><span class="hljs-comment"> * in the Software without restriction, including without limitation the rights</span><br><span class="hljs-comment"> * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span><br><span class="hljs-comment"> * copies of the Software, and to permit persons to whom the Software is</span><br><span class="hljs-comment"> * furnished to do so, subject to the following conditions:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The above copyright notice and this permission notice shall be included in</span><br><span class="hljs-comment"> * all copies or substantial portions of the Software.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span><br><span class="hljs-comment"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span><br><span class="hljs-comment"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span><br><span class="hljs-comment"> * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span><br><span class="hljs-comment"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span><br><span class="hljs-comment"> * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN</span><br><span class="hljs-comment"> * THE SOFTWARE.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">package</span> com.github.pagehelper;<br><br><span class="hljs-keyword">import</span> com.github.pagehelper.cache.Cache;<br><span class="hljs-keyword">import</span> com.github.pagehelper.cache.CacheFactory;<br><span class="hljs-keyword">import</span> com.github.pagehelper.util.ExecutorUtil;<br><span class="hljs-keyword">import</span> com.github.pagehelper.util.MSUtils;<br><span class="hljs-keyword">import</span> com.github.pagehelper.util.StringUtil;<br><span class="hljs-keyword">import</span> org.apache.ibatis.cache.CacheKey;<br><span class="hljs-keyword">import</span> org.apache.ibatis.executor.Executor;<br><span class="hljs-keyword">import</span> org.apache.ibatis.mapping.BoundSql;<br><span class="hljs-keyword">import</span> org.apache.ibatis.mapping.MappedStatement;<br><span class="hljs-keyword">import</span> org.apache.ibatis.plugin.*;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.ResultHandler;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.RowBounds;<br><br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Mybatis - 通用分页拦截器</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * GitHub: https://github.com/pagehelper/Mybatis-PageHelper</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * Gitee : https://gitee.com/free/Mybatis_PageHelper</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> liuzh/abel533/isea533</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 5.0.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span><br><span class="hljs-meta">@Intercepts(</span><br><span class="hljs-meta">        &#123;</span><br><span class="hljs-meta">                @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;),</span><br><span class="hljs-meta">                @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class&#125;),</span><br><span class="hljs-meta">        &#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Dialect dialect;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">countSuffix</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;_COUNT&quot;</span>;<br>    <span class="hljs-keyword">protected</span> Cache&lt;String, MappedStatement&gt; msCountMap = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">default_dialect_class</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.github.pagehelper.PageHelper&quot;</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Object[] args = invocation.getArgs();<br>            <span class="hljs-type">MappedStatement</span> <span class="hljs-variable">ms</span> <span class="hljs-operator">=</span> (MappedStatement) args[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">parameter</span> <span class="hljs-operator">=</span> args[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">RowBounds</span> <span class="hljs-variable">rowBounds</span> <span class="hljs-operator">=</span> (RowBounds) args[<span class="hljs-number">2</span>];<br>            <span class="hljs-type">ResultHandler</span> <span class="hljs-variable">resultHandler</span> <span class="hljs-operator">=</span> (ResultHandler) args[<span class="hljs-number">3</span>];<br>            <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> (Executor) invocation.getTarget();<br>            CacheKey cacheKey;<br>            BoundSql boundSql;<br>            <span class="hljs-comment">//由于逻辑关系，只会进入一次</span><br>            <span class="hljs-keyword">if</span> (args.length == <span class="hljs-number">4</span>) &#123;<br>                <span class="hljs-comment">//4 个参数时</span><br>                boundSql = ms.getBoundSql(parameter);<br>                cacheKey = executor.createCacheKey(ms, parameter, rowBounds, boundSql);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//6 个参数时</span><br>                cacheKey = (CacheKey) args[<span class="hljs-number">4</span>];<br>                boundSql = (BoundSql) args[<span class="hljs-number">5</span>];<br>            &#125;<br>            checkDialectExists();<br>            <span class="hljs-comment">//对 boundSql 的拦截处理</span><br>            <span class="hljs-keyword">if</span> (dialect <span class="hljs-keyword">instanceof</span> BoundSqlInterceptor.Chain) &#123;<br>                boundSql = ((BoundSqlInterceptor.Chain) dialect).doBoundSql(BoundSqlInterceptor.Type.ORIGINAL, boundSql, cacheKey);<br>            &#125;<br>            List resultList;<br>            <span class="hljs-comment">//调用方法判断是否需要进行分页，如果不需要，直接返回结果</span><br>            <span class="hljs-keyword">if</span> (!dialect.skip(ms, parameter, rowBounds)) &#123;<br>                <span class="hljs-comment">//判断是否需要进行 count 查询</span><br>                <span class="hljs-keyword">if</span> (dialect.beforeCount(ms, parameter, rowBounds)) &#123;<br>                    <span class="hljs-comment">//查询总数</span><br>                    <span class="hljs-type">Long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> count(executor, ms, parameter, rowBounds, <span class="hljs-literal">null</span>, boundSql);<br>                    <span class="hljs-comment">//处理查询总数，返回 true 时继续分页查询，false 时直接返回</span><br>                    <span class="hljs-keyword">if</span> (!dialect.afterCount(count, parameter, rowBounds)) &#123;<br>                        <span class="hljs-comment">//当查询总数为 0 时，直接返回空的结果</span><br>                        <span class="hljs-keyword">return</span> dialect.afterPage(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(), parameter, rowBounds);<br>                    &#125;<br>                &#125;<br>                resultList = ExecutorUtil.pageQuery(dialect, executor,<br>                        ms, parameter, rowBounds, resultHandler, boundSql, cacheKey);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//rowBounds用参数值，不使用分页插件处理时，仍然支持默认的内存分页</span><br>                resultList = executor.query(ms, parameter, rowBounds, resultHandler, cacheKey, boundSql);<br>            &#125;<br>            <span class="hljs-keyword">return</span> dialect.afterPage(resultList, parameter, rowBounds);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span>(dialect != <span class="hljs-literal">null</span>)&#123;<br>                dialect.afterAll();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Spring bean 方式配置时，如果没有配置属性就不会执行下面的 setProperties 方法，就不会初始化</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 因此这里会出现 null 的情况 fixed #26</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkDialectExists</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (dialect == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (default_dialect_class) &#123;<br>                <span class="hljs-keyword">if</span> (dialect == <span class="hljs-literal">null</span>) &#123;<br>                    setProperties(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>());<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Long <span class="hljs-title function_">count</span><span class="hljs-params">(Executor executor, MappedStatement ms, Object parameter,</span><br><span class="hljs-params">                       RowBounds rowBounds, ResultHandler resultHandler,</span><br><span class="hljs-params">                       BoundSql boundSql)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">countMsId</span> <span class="hljs-operator">=</span> ms.getId() + countSuffix;<br>        Long count;<br>        <span class="hljs-comment">//先判断是否存在手写的 count 查询</span><br>        <span class="hljs-type">MappedStatement</span> <span class="hljs-variable">countMs</span> <span class="hljs-operator">=</span> ExecutorUtil.getExistedMappedStatement(ms.getConfiguration(), countMsId);<br>        <span class="hljs-keyword">if</span> (countMs != <span class="hljs-literal">null</span>) &#123;<br>            count = ExecutorUtil.executeManualCount(executor, countMs, parameter, boundSql, resultHandler);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (msCountMap != <span class="hljs-literal">null</span>) &#123;<br>                countMs = msCountMap.get(countMsId);<br>            &#125;<br>            <span class="hljs-comment">//自动创建</span><br>            <span class="hljs-keyword">if</span> (countMs == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//根据当前的 ms 创建一个返回值为 Long 类型的 ms</span><br>                countMs = MSUtils.newCountMappedStatement(ms, countMsId);<br>                <span class="hljs-keyword">if</span> (msCountMap != <span class="hljs-literal">null</span>) &#123;<br>                    msCountMap.put(countMsId, countMs);<br>                &#125;<br>            &#125;<br>            count = ExecutorUtil.executeAutoCount(<span class="hljs-built_in">this</span>.dialect, executor, countMs, parameter, boundSql, rowBounds, resultHandler);<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">plugin</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-keyword">return</span> Plugin.wrap(target, <span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProperties</span><span class="hljs-params">(Properties properties)</span> &#123;<br>        <span class="hljs-comment">//缓存 count ms</span><br>        msCountMap = CacheFactory.createCache(properties.getProperty(<span class="hljs-string">&quot;msCountCache&quot;</span>), <span class="hljs-string">&quot;ms&quot;</span>, properties);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">dialectClass</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;dialect&quot;</span>);<br>        <span class="hljs-keyword">if</span> (StringUtil.isEmpty(dialectClass)) &#123;<br>            dialectClass = default_dialect_class;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; aClass = Class.forName(dialectClass);<br>            dialect = (Dialect) aClass.newInstance();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageException</span>(e);<br>        &#125;<br>        dialect.setProperties(properties);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">countSuffix</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;countSuffix&quot;</span>);<br>        <span class="hljs-keyword">if</span> (StringUtil.isNotEmpty(countSuffix)) &#123;<br>            <span class="hljs-built_in">this</span>.countSuffix = countSuffix;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DHand-Cloud</title>
    <link href="/2024/05/23/DHand-Cloud/"/>
    <url>/2024/05/23/DHand-Cloud/</url>
    
    <content type="html"><![CDATA[<h1 id="DHand项目"><a href="#DHand项目" class="headerlink" title="DHand项目"></a>DHand项目</h1><h2 id="Search模块"><a href="#Search模块" class="headerlink" title="Search模块"></a>Search模块</h2><p><img src="/2024/05/23/DHand-Cloud/Search%E6%A8%A1%E5%9D%97.png"></p><h3 id="ES的常规使用"><a href="#ES的常规使用" class="headerlink" title="ES的常规使用"></a>ES的常规使用</h3><ol><li>ES是一个开源的搜索和分析引擎。常用于全文搜索、结构化搜索、分析。主要有索引、文档、字段、映射这些基本的概念。</li><li>基本的增删改操作：对索引、文档进行一些增删改操作，指令分别为POST、PUT、DEL等。</li><li>查询操作（query）：查询是ES的一个重要功能。查询可以分类为全文检索（match、mutil_match)、精准查询（term、range）、地理查询（geo）、复合查询（算分函数查询、布尔查询【must、should、must_not、filter】。</li><li>处理查询结果：对查询结果的处理有排序、分页、高亮三个常见的操作。排序（sort）默认会使用自带的score进行排序，也可以自定义排序。分页（from、size）阻止查询id大于10000的文档。高亮（highlight）则是通过添加标签然后网页对标签添加css样式。</li><li>聚合（aggregation）：常分为三类，桶（bucket）、度量（metric）和管道（pipeline）。桶聚合用来对文档做分组，度量则是用以计算一些值，如最大值、最小值、平均值等。管道则是其他聚合结果为基础做聚合。</li></ol><h3 id="Springboot项目整合ES"><a href="#Springboot项目整合ES" class="headerlink" title="Springboot项目整合ES"></a>Springboot项目整合ES</h3><ol><li>导入相关pom依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>配置yml文件</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">data:</span><br>    <span class="hljs-attr">elasticsearch:</span><br>      <span class="hljs-attr">repositories:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">elasticsearch:</span><br>    <span class="hljs-attr">uris:</span> <span class="hljs-string">localhost:9200</span><br></code></pre></td></tr></table></figure><ol start="3"><li>创建实体类和仓库接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Document(indexName = &quot;blog&quot;, type = &quot;article&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Article</span> &#123;<br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-keyword">private</span> String id;<br>    <span class="hljs-keyword">private</span> String title;<br>    <span class="hljs-keyword">private</span> String content;<br>    <span class="hljs-comment">// 省略getter和setter</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ArticleRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ElasticsearchRepository</span>&lt;Article, String&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>创建服务层</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArticleService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ArticleRepository articleRepository;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveArticle</span><span class="hljs-params">(Article article)</span> &#123;<br>        articleRepository.save(article);<br>    &#125;<br><br>    <span class="hljs-comment">// 添加更多服务方法</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>controller层</li></ol><h3 id="主要数据库的设计"><a href="#主要数据库的设计" class="headerlink" title="主要数据库的设计"></a>主要数据库的设计</h3><ol><li>二手书数据库表：书籍ID、书名、作者、出版社、ISBN、出版日期、分类（小说、教育、科技）、价格、书籍状态（全新、几乎全新、轻微磨损、少量笔记）、备注。</li><li>二手书ES索引：<ol><li>用于搜索框的字段【全文检索mutil-match】：书名（textword）、作者（keyword）、出版社（textword）、ISBN（keyword）</li><li>用于精确查询【精确查询term】：科别（工科、理科、管理科、其他等） 类别（小说、漫画、教科书、其他等）</li><li>用于范围查询【范围查询range】：价格</li></ol></li></ol><h3 id="导入所有数据库数据到ES"><a href="#导入所有数据库数据到ES" class="headerlink" title="导入所有数据库数据到ES"></a>导入所有数据库数据到ES</h3><p>查询数据库的信息，使用Mybatis编写SQL语句，使用resultMap将结果映射成ES的实体。然后调用Dao层提供的saveAll方法。大致代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">importAll</span><span class="hljs-params">()</span> &#123;<br>        List&lt;EsProduct&gt; esProductList = productDao.getAllEsProductList(<span class="hljs-literal">null</span>);<br>        Iterable&lt;EsProduct&gt; esProductIterable = productRepository.saveAll(esProductList);<br>        Iterator&lt;EsProduct&gt; iterator = esProductIterable.iterator();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            result++;<br>            iterator.next();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="增加、删除、修改ES的文档"><a href="#增加、删除、修改ES的文档" class="headerlink" title="增加、删除、修改ES的文档"></a>增加、删除、修改ES的文档</h3><p>增加：根据id查询数据库得到ES的实体后执行DAO层save方法。</p><p>删除：直接根据id执行DAO的delete方法。</p><h3 id="简单搜索"><a href="#简单搜索" class="headerlink" title="简单搜索"></a>简单搜索</h3><p>只根据搜索框的内容进行搜索,传入keyword和pageNum和pageSize</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Page&lt;EsProduct&gt; <span class="hljs-title function_">search</span><span class="hljs-params">(String keyword, Integer pageNum, Integer pageSize)</span> &#123;<br>        <span class="hljs-type">Pageable</span> <span class="hljs-variable">pageable</span> <span class="hljs-operator">=</span> PageRequest.of(pageNum, pageSize);<br>        <span class="hljs-keyword">return</span> productRepository.findByNameOrSubTitleOrKeywords(keyword, keyword, keyword, pageable);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="综合搜索"><a href="#综合搜索" class="headerlink" title="综合搜索"></a>综合搜索</h3><p>在简单搜索的基础上，添加排序、筛选功能。排序则是可以根据默认（得分）、时间（最新）、价格。筛选则可以根据科别和类别进行筛选。</p><p>大致步骤就是先创建一个nativeSearchQueryBuilder，然后先分页，再过滤，再文件检索、再排序。最后调用build方法得到NativeSearchQuery。最后执行search方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Page&lt;EsProduct&gt; <span class="hljs-title function_">search</span><span class="hljs-params">(String keyword, Long brandId, Long productCategoryId,</span><br><span class="hljs-params">                                  Integer pageNum, Integer pageSize,Integer sort)</span> &#123;<br>        <span class="hljs-type">Pageable</span> <span class="hljs-variable">pageable</span> <span class="hljs-operator">=</span> PageRequest.of(pageNum, pageSize);<br>        <span class="hljs-type">NativeSearchQueryBuilder</span> <span class="hljs-variable">nativeSearchQueryBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NativeSearchQueryBuilder</span>();<br>        <span class="hljs-comment">//分页</span><br>        nativeSearchQueryBuilder.withPageable(pageable);<br>        <span class="hljs-comment">//过滤</span><br>        <span class="hljs-keyword">if</span> (brandId != <span class="hljs-literal">null</span> || productCategoryId != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">BoolQueryBuilder</span> <span class="hljs-variable">boolQueryBuilder</span> <span class="hljs-operator">=</span> QueryBuilders.boolQuery();<br>            <span class="hljs-keyword">if</span> (brandId != <span class="hljs-literal">null</span>) &#123;<br>                boolQueryBuilder.must(QueryBuilders.termQuery(<span class="hljs-string">&quot;brandId&quot;</span>, brandId));<br>            &#125;<br>            <span class="hljs-keyword">if</span> (productCategoryId != <span class="hljs-literal">null</span>) &#123;<br>                boolQueryBuilder.must(QueryBuilders.termQuery(<span class="hljs-string">&quot;productCategoryId&quot;</span>, productCategoryId));<br>            &#125;<br>            nativeSearchQueryBuilder.withFilter(boolQueryBuilder);<br>        &#125;<br>        <span class="hljs-comment">//搜索</span><br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(keyword)) &#123;<br>            nativeSearchQueryBuilder.withQuery(QueryBuilders.matchAllQuery());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            List&lt;FunctionScoreQueryBuilder.FilterFunctionBuilder&gt; filterFunctionBuilders = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            filterFunctionBuilders.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FunctionScoreQueryBuilder</span>.FilterFunctionBuilder(QueryBuilders.matchQuery(<span class="hljs-string">&quot;name&quot;</span>, keyword),<br>                    ScoreFunctionBuilders.weightFactorFunction(<span class="hljs-number">10</span>)));<br>            filterFunctionBuilders.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FunctionScoreQueryBuilder</span>.FilterFunctionBuilder(QueryBuilders.matchQuery(<span class="hljs-string">&quot;subTitle&quot;</span>, keyword),<br>                    ScoreFunctionBuilders.weightFactorFunction(<span class="hljs-number">5</span>)));<br>            filterFunctionBuilders.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FunctionScoreQueryBuilder</span>.FilterFunctionBuilder(QueryBuilders.matchQuery(<span class="hljs-string">&quot;keywords&quot;</span>, keyword),<br>                    ScoreFunctionBuilders.weightFactorFunction(<span class="hljs-number">2</span>)));<br>            FunctionScoreQueryBuilder.FilterFunctionBuilder[] builders = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FunctionScoreQueryBuilder</span>.FilterFunctionBuilder[filterFunctionBuilders.size()];<br>            filterFunctionBuilders.toArray(builders);<br>            <span class="hljs-type">FunctionScoreQueryBuilder</span> <span class="hljs-variable">functionScoreQueryBuilder</span> <span class="hljs-operator">=</span> QueryBuilders.functionScoreQuery(builders)<br>                    .scoreMode(FunctionScoreQuery.ScoreMode.SUM)<br>                    .setMinScore(<span class="hljs-number">2</span>);<br>            nativeSearchQueryBuilder.withQuery(functionScoreQueryBuilder);<br>        &#125;<br>        <span class="hljs-comment">//排序</span><br>        <span class="hljs-keyword">if</span>(sort==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">//按新品从新到旧</span><br>            nativeSearchQueryBuilder.withSort(SortBuilders.fieldSort(<span class="hljs-string">&quot;id&quot;</span>).order(SortOrder.DESC));<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sort==<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-comment">//按销量从高到低</span><br>            nativeSearchQueryBuilder.withSort(SortBuilders.fieldSort(<span class="hljs-string">&quot;sale&quot;</span>).order(SortOrder.DESC));<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sort==<span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-comment">//按价格从低到高</span><br>            nativeSearchQueryBuilder.withSort(SortBuilders.fieldSort(<span class="hljs-string">&quot;price&quot;</span>).order(SortOrder.ASC));<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sort==<span class="hljs-number">4</span>)&#123;<br>            <span class="hljs-comment">//按价格从高到低</span><br>            nativeSearchQueryBuilder.withSort(SortBuilders.fieldSort(<span class="hljs-string">&quot;price&quot;</span>).order(SortOrder.DESC));<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//按相关度</span><br>            nativeSearchQueryBuilder.withSort(SortBuilders.scoreSort().order(SortOrder.DESC));<br>        &#125;<br>        nativeSearchQueryBuilder.withSort(SortBuilders.scoreSort().order(SortOrder.DESC));<br>        <span class="hljs-type">NativeSearchQuery</span> <span class="hljs-variable">searchQuery</span> <span class="hljs-operator">=</span> nativeSearchQueryBuilder.build();<br>        LOGGER.info(<span class="hljs-string">&quot;DSL:&#123;&#125;&quot;</span>, searchQuery.getQuery().toString());<br>        SearchHits&lt;EsProduct&gt; searchHits = elasticsearchRestTemplate.search(searchQuery, EsProduct.class);<br>        <span class="hljs-keyword">if</span>(searchHits.getTotalHits()&lt;=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageImpl</span>&lt;&gt;(<span class="hljs-literal">null</span>,pageable,<span class="hljs-number">0</span>);<br>        &#125;<br>        List&lt;EsProduct&gt; searchProductList = searchHits.stream().map(SearchHit::getContent).collect(Collectors.toList());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageImpl</span>&lt;&gt;(searchProductList,pageable,searchHits.getTotalHits());<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="为什么使用ES而不是用MySQL进行搜索"><a href="#为什么使用ES而不是用MySQL进行搜索" class="headerlink" title="为什么使用ES而不是用MySQL进行搜索"></a>为什么使用ES而不是用MySQL进行搜索</h2><ol><li>首先搜索的场景一般是通过一个搜索框，还有一些给定的分类进行点击来搜索。搜索框输入对应的text，如果走MySQL就需要使用模糊查询来解决，而模糊查询是不走索引的，而会全表扫描。然后点击类别的话，维度很高，用户选择具有不确定性，复合索引遵循最左匹配原则无法生效。</li></ol><h3 id="ES和SQL的搭配"><a href="#ES和SQL的搭配" class="headerlink" title="ES和SQL的搭配"></a>ES和SQL的搭配</h3><p>ES做全搜索，MySQL做商品详情，增删改查功能。当MySQL数据发生变化，则需要同步到ES。</p><h3 id="ES和MySQL的一致性"><a href="#ES和MySQL的一致性" class="headerlink" title="ES和MySQL的一致性"></a>ES和MySQL的一致性</h3><ol><li>双写同步：在应用层同时向MySQL和ES写入数据。简单直接，但存在风险，比如写入一个系统成功而另一个系统失败时会导致数据不一致。</li><li>消息队列：当数据在MySQL中被修改时，相应的事件将被发送到消息队列中，然后由一个或多个消费者处理这些事件来更新ES。</li><li>定时任务：创建定时任务（cron jobs）或使用调度工具（quartz）来定期同步MySQL和ES之间的数据。可能不适合实时搜索的需求，但对于不需要实时索引的场景是有效的。</li><li>使用RabbitMQ进行同步：在对数据库书籍表进行增删改的操作添加发送消息到MQ的步骤。发送消息到使用topic交换机，topic交换机绑定两个队列，一个用于增改，一个用于删除。再添加消费者（使用@rabbitListener）去监听队列。</li></ol><h2 id="Auth模块"><a href="#Auth模块" class="headerlink" title="Auth模块"></a>Auth模块</h2><h2 id="订单模块"><a href="#订单模块" class="headerlink" title="订单模块"></a>订单模块</h2><p><img src="/2024/05/23/DHand-Cloud/%E8%AE%A2%E5%8D%95%E6%A8%A1%E5%9D%97.png"></p><h3 id="订单确认"><a href="#订单确认" class="headerlink" title="订单确认"></a>订单确认</h3><p>首先，订单提交涉及了多个步骤，第一点，你首先要知道买了什么东西，第二，你要知道用户的收货地址。先分析第一点，我这个校园二手交易平台没有提供购物车的功能，所以就只有立即购买的按钮，同时也就只会购买一件商品。就需要通过商品id去数据库查询商品的相关信息。第二点，我这个项目的活动范围是一个校园，所以用户的收获地址和其他网购APP还不太一样，只支持校园+园区或者楼栋号+宿舍号这种方式来填写收获地址。所以就需要获取用户的id去数据库查询用户相关信息，这里两部分的信息都需要用到openFeign去请求，因为用户模块、商品模块和订单模块都是不同的微服务模块。还有第三点，就是为了防止订单重复提交我还使用了redis生成一个唯一令牌的操作。这三个部分的操作集合起来这个订单确认业务就太耗时间了，所以为了减少时间我就采用了CompleteFurture的方式异步执行这三个任务，并行执行提高效率，提高相应速率。同时也提供了失败异常处理的机制。最后调用了join方法等待三个任务全部完成之后才会返回结果。</p><h3 id="订单提交"><a href="#订单提交" class="headerlink" title="订单提交"></a>订单提交</h3><p>订单确认之后，就可以点击提交按钮，首先进行订单是否重复提交的判断，主要是通过redis和lua脚本来实现的。在订单确认功能那里，设置了一个唯一令牌，第一次提交时查询到了这个令牌，之后删除，第二次再次提交，查询不到对应的令牌，就不可继续。这样就防止了订单的重复提交。但是这个操作是两阶段的，也就是查询和删除，会有线程不安全的情况，所以就使用了lua脚本确保操作的原子性。然后要确保在订单确认和订单提交这一过程中订单的相关信息的校验，校验的信息包含商品是不是卖完了，商品的价格是不是发生了变化。这一部分使用了fegin远程调用获取了商品的信息和使用了java的流模式和Assert断言使得校验更加方便。如果校验成功的话则进行校验库存和锁定库存。最后生成订单。设置订单为未支付状态，并提供了订单超时未支付取消的操作，主要是通过MQ实现的，</p><h3 id="订单支付"><a href="#订单支付" class="headerlink" title="订单支付"></a>订单支付</h3><p>订单支付时需要使用分布式锁来确保订单重复支付，项目中使用的是redission锁来实现的。键值是订单的编号。订单支付是采用余额支付的形式，扣减库存和更新订单状态。</p><h3 id="订单超时取消"><a href="#订单超时取消" class="headerlink" title="订单超时取消"></a>订单超时取消</h3><p>首先，订单提交后一般会有一个时间，在这个时间未支付则会被视为取消订单。这种超时取消的业务一般的实现方式有定时任务调度，延迟队列等。延迟队列就是消息在队列中过一段时间在被消费掉。在项目里头我使用了RabbitMQ，本质上RabbitMQ是不支持延迟队列的，但使用了死信队列来实现这种类似的延迟队列。死信队列就是一个队列的信息得不到消费，一般有以下几种情况。队列没有消费者，一段时间后超时未消费。还有就是队列的消息过多，导致消息进不去队列，丢失了。项目里头主要用了第一种。首先需要创建一个普通的交换机和一个队列，绑定在一起，生产者往这交换机发送信息。这个队列需要设置一个参数TTL。而且这个队列不允许设置消费者。然后要创建一个死信交换机和死信队列。前面那个普通的队列和这个死信交换机进行绑定，设置消息超时就发送到这个死信交换机中。然后这个死信队列设置消费者去取消订单。</p><h2 id="IM模块"><a href="#IM模块" class="headerlink" title="IM模块"></a>IM模块</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaLearning522</title>
    <link href="/2024/05/22/JavaLearning522/"/>
    <url>/2024/05/22/JavaLearning522/</url>
    
    <content type="html"><![CDATA[<h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><p>悲观锁：认为多线程安全问题一定会发生。所以在操作数据时先加锁。应用于写操作频繁的场景。</p><p>乐观锁：认为多线程安全问题不一定会发生。所以在草所数据时不加锁，直到数据更新后进行判断该时间段中数据是否发生变化。应用于读操作频繁的场景下。有版本号法，</p><p>版本号法：给原数据库表添加一个字段version，更新时查询version的值，执行更新时在where语句后添加version判断是否为更新前的version值，并且需要 <code>set version = version + 1</code>进行版本的更新。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 假设我们从应用程序获取了用户数据，并且当前的版本号是1<br>SELECT id, username, email, version FROM users WHERE username = &#x27;alice&#x27;;<br>-- 返回：1, &#x27;alice&#x27;, &#x27;alice@example.com&#x27;, 1<br><br>-- 用户提交了更新邮箱地址的请求，我们尝试更新记录<br>UPDATE users SET email = &#x27;newalice@example.com&#x27;, version = version + 1 WHERE username = &#x27;alice&#x27; AND version = 1;<br></code></pre></td></tr></table></figure><p>CAS法：compare-and-swap，是一个原子操作，依赖于底层的硬件的支持。首先有三个值，V代表内存位置的值，A代表预期的值，B代表新修改的值。基本步骤为读取当前内存地址的值V，然后V和A进行对比，一样则说明没有其他线程修改当前值，则该线程进行修改。尽管CAS提供了一种搞笑的方式实现无锁方式，但存在以下几种问题。</p><ol><li>ABA问题：一个值A从到修改为B，再修改为A，前后虽然一致，但中间发生了修改操作。</li><li>自旋问题：进行CAS时会使用do while进行判断，失败即会进行自旋，重复CAS操作直到成功，可能会CPU资源的消耗。</li><li>只能保证单个变量的原子操作：</li></ol><p>在Java中的concurrent包中提供了很多的原子操作的类，例如AtomicInteger，其底层就是采用了CAS原理。提供了一种线程安全的方式来操作单个<code>int</code>值，无需使用<code>synchronized</code>关键字。这使得它在高并发环境下比锁有更好的性能。常用的方法有get、set、getAndSet、compareAndSet等方法。</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>首先reentranLock是concurrent提供的一个类，相比于synchronized提供了更多的锁操作。例如可以尝试获取锁tryLock()、获取锁时可中断等。</p><p>其底层原理是一个同步组件AQS，abstractQueueSynchronizer。其实现类为Sync，有具体分为安全的FairSync和非安全的NoFairSync。默认是非安全的。</p><p>NoFairSync.lock方法：</p><p>调用lock方法实际上是调用了同步组件的lock方法。获取锁的过程也是通过CAS进行判断的。获取锁成功后会将state转换为1，然后标识当前锁的线程。然后下次获取锁时，如果获取失败的话就会调用acquire方法，该方法会调用tryacquire方法，再次尝试获取锁，比较state的值是否为0，否的话则比较是否为当前线程，是的话就表示可以重入。如果都不成功则tryacquire方法会返回false，将当前进程 进入<strong>acquireQueued()</strong> 流程。也就是基于CLH队列的抢占模式。在此之间会调用addWaiter方法创建一个节点或者初始化队列。然后将其挂起。</p><p>NoFairSync.unclock方法：</p><ol><li>调用 <strong>unlock()</strong> 方法，其实是直接调用 <strong>AbstractQueuedSynchronizer.release()</strong> 操作。</li><li>进入 <strong>release()</strong> 方法，内部先尝试 <strong>tryRelease()</strong> 操作,主要是去除锁的独占线程，然后将状态减一，这里减一主要是考虑到可重入锁可能自身会多次占用锁，只有当状态变成0，才表示完全释放了锁。</li><li>如果 <strong>tryRelease</strong> 成功，则将CHL队列的头节点的状态设置为0，然后唤醒下一个非取消的节点线程。</li><li>一旦下一个节点的线程被唤醒，被唤醒的线程就会进入 <strong>acquireQueued()</strong> 代码流程中，去获取锁。</li></ol><p>AQS：有一个state用于维持所的状态，有一个exclusiveThread用于指向当前持有锁的线程，有一个Head和tail的Node节点，用于维护等待队列。Node节点有前后指针，形成一个双向链表。</p><p>引用：<a href="https://zhuanlan.zhihu.com/p/517749666">深入浅出ReentrantLock(可重入锁) - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redission的深入学习</title>
    <link href="/2024/05/22/Redission%E7%9A%84%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/05/22/Redission%E7%9A%84%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="redission分布式锁"><a href="#redission分布式锁" class="headerlink" title="redission分布式锁"></a>redission分布式锁</h2><ol><li>通过redis的setnx命令实现的。redis的单线程的，所谓的单线程是执行指令的过程是单线程的。做法为<code>setnx key value ex time</code>。</li><li>分布式锁误删的情况<ol><li>误删情况一：一般锁会设置过期时间，现在有两个线程A和B，A创建锁后被阻塞了，到了过期时间锁删了，然后B创建了锁，A和B对于锁的标识是一样的，即对应的Key值是一样的。此时A不阻塞了，执行完毕删除了B创建的锁。解决思路：此时锁只用到了key值，value值为使用到。所以value值可以存储线程相应的信息，在删除锁时判断该锁是否为自己线程所创建。</li><li>误删情况二：在情况一的基础上，需要获取锁得value值然后再判断是否删除，这又是两个操作。所以还会出现更加极端的误删情况。线程A判断得到该锁为自己所创建之后阻塞了直到锁过期了。然后线程B创建锁，线程A不阻塞了删除了B的锁。解决思路：使用redis提供的lua脚本。lua脚本的命令格式为<code>redis.call(&#39;命令名称&#39;, &#39;key&#39;, &#39;其它参数&#39;, ...)</code>。在redis层面则是通过<code>EVAL</code>命令来执行lua脚本。在Java层面的redisTemplate则使用execute方法执行lua脚本。脚本可以传递参数。</li></ol></li><li>redission锁<ol><li>基于redis的setnx实现的分布式锁有很多的问题。一是<strong>不可重入</strong>，可重入是指获取锁的线程可以进入到相同的锁的代码块中。二是<strong>不可失败重试</strong>，获取锁失败后无法再次获取锁，除了再一次的发起请求。三是<strong>超时释放</strong>，我们给锁加了过期时间，超时了会自动释放。四是<strong>主从一致性</strong>，如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</li><li>redission是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。驻内存网络是通过利用内存存储而非传统的磁盘存储，它允许数据在多个服务器的内存中分布存储。</li><li><strong>redission的可重入原理</strong>：存储锁的数据类型是通过hash存储的。hash也是存储key value值的数据，而value是存储filed和value的数据。所以就比setnx多了一个层面。所以大key就代表锁的标识，小key也就是filed代表线程的标识，也就是创建当前锁的线程，value则是state值。通过判断大key值是否存在即可判断是否存在锁，通过判断filed是否和当前线程一致可以判断锁是否为当前线程所创建，如果一致则通过value值加1来实现可重入。如果第一步直接创建锁成功或者第二步判断得到该所可重入的话，脚本会返回null值，反之则会返回ttl（Time To Live）值，也就是该锁剩余的时间。</li><li><strong>redission的失败重试原理</strong>：首先会有一个waitTime的参数来代表获取锁的最大等待时间。超过该时间即不再重新尝试获取锁。首先waitTime会减去第一次尝试获取锁花费的时间，得到剩余的waitTime，小于零即不再重试。大于零即代表还会重试。但重试不是立即去获取锁，而是开启一个订阅去订阅锁的信息【这里和锁释放时调用的unlock方法会publish信息进行对应】。当接收到订阅消息则开始一个while循环去再次获取锁，同样还是会判断剩余的waitTime和零的关系和再次监听锁的信息。</li><li><strong>redisiion的看门狗原理</strong>：首先会执行获取锁的脚本，如返回值为null，也就是创建成功，如果返回的是ttl，则代表返回失败。获取到锁且leaseTime值为1时，则会调用方法scheduleExpirationRenewal去重新刷新过期时间。redissionLock会维护一个静态成员变量<code>EXPIRATION_RENEWAL_MAP</code>来存储过期实体expirationEntry，最后开启一个任务Task，每隔10s【看门狗时间的1&#x2F;3，原默认是30s】，去获取相应的实体的key值得到对应在redis的相关信息然后执行lua脚本刷新超时时间。</li><li><strong>unlock方法</strong>：先判断锁是否存在，不存在返回null，存在则再value值-1，再判断value是否大于0，大于0则代表还有线程持有锁，返回null，反之则没有，即可释放锁。释放锁会del对应的锁，还会publish一个信号<code>&quot;redis.call(&#39;publish&#39;, KEYS[2], ARGV[1])</code>供失败重试的线程订阅。最后还会关闭掉看门狗开启的Task<code>cancelExpirationRenewal(threadId);</code>。</li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试</title>
    <link href="/2024/05/21/%E6%B5%8B%E8%AF%95/"/>
    <url>/2024/05/21/%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><ol><li>测试用例是软件测试领域中的一个基本概念，为了验证软件应用程序的某个特定功能或者特性是否按照要求正常工作的一组测试步骤、预期结果和测试条件的相应描述。通常包括以下几个关键部分：测试用例ID、测试用例标题、描述、前置条件、测试步骤、测试数据、预期结果、实际结果和测试结果和备注等等信息。</li><li>测试用例的设计方法：黑盒测试和白盒测试。<ol><li>黑盒测试（关注于软件的功能性需求，不考虑内部实现细节）：等价类划分、边界值分析、判定表测试、状态转换测试、因果图法</li><li>白盒测试（关注于程序的内部逻辑结构）：语句覆盖、判定覆盖、条件覆盖等等</li></ol></li></ol><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>负载测试 压力测试 故障恢复测试</p><ol><li>Jmeter工具的使用<ol><li>创建线程组：可以设置线程数量，持续时间，循环次数（也就是每个线程调用的次数）</li><li>创建采样：例如可以创建HTTP请求，设置对应的协议，主机号，端口号，方法类型，路径，请求编码类型，参数</li><li>创建断言：可以根据对请求的相应或者参数进行断言的校验，校验的模式一般有包括，匹配，相等啥的，跟Java代码层面上的Assert类大致一致</li><li>创建前置&#x2F;后置处理器：</li><li>添加配置文件：测试用例的参数值肯定不是固定为一个值的，所以可以通过将要查的参数值存储在类似的csv文件中。</li><li>创建监视器：创建察看结果树可以查看每次请求是否成功及其相应结果。同时可以创建对应的聚合结果，可以分析聚合结果，查看平均响应时间、错误率、吞吐量等等</li></ol></li><li>例子：为了测试MySQL索引的好处，我创建了一个表，表中有十几万条数据，表的列有id，o-id，create-time，然后执行SQL查询时根据u-id进行查询并根据create-time进行排序，o-id又是不规则的，再没加索引之前，每次查询就都是全表查询，线程组是1000时，csv有差不错一万条数据，然后的出来的聚合结果分析吞吐量20左右。最大的线程相应时间花了50s左右。然后创建联合索引（o-id，create-time）之后吞吐量达到1000左右，总时间花了不到1s。</li><li>项目中用了jmeter去测试库存超卖的问题，主要是为了去模拟高并发的情况。</li></ol><h2 id="测试自动化"><a href="#测试自动化" class="headerlink" title="测试自动化"></a>测试自动化</h2><ol><li><p>测试自动化：使用特定的工具和脚本自动执行测试用例，为了提高测试效率，测试覆盖率和准确率。</p></li><li><p>步骤：</p><ol><li>需求分析：评估哪些测试用例适合自动化，如高风险、高价值以及重复执行的测试用例。</li><li>选则测试的工具：</li><li>设置测试策略和计划：</li><li>设置测试环境：</li><li>自动化测试用例设计：</li><li>编写测试脚本：</li><li>执行测试：<br>结果分析：</li></ol></li><li><p>自动化框架搭建流程：</p><ol><li>模块化设计</li><li>日志记录</li><li>数据驱动</li><li>缺陷报告</li><li>持续继承</li><li>兼容性测试</li></ol></li></ol><h2 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI&#x2F;CD"></a>CI&#x2F;CD</h2><ol><li>CI：持续集成的意思，开发团队成员经常将代码变更集成到共享仓库中，每次集成都通过自动化构建来验证，以便尽快发现集成错误。版本控制：GIT，自动化构建和测试：Jenkins。</li><li>CD：持续部署的意思，在持续集成的基础上，自动化将代码变更部署到生产环境的过程。</li></ol><h2 id="测试的分类"><a href="#测试的分类" class="headerlink" title="测试的分类"></a>测试的分类</h2><ol><li>按开发过程分：<ol><li>单元测试：对软件的组成单位即模块进行测试，是白盒测试。</li><li>集成测试：将程序模块采用适当的集成策略组装起来，对系统的接口及集成后的功能进行正确性检测的测试性工作，检查软件的单位之间的接口是否正确。</li><li>系统测试：整体的一个测试。</li></ol></li><li>按测试对象分：<ol><li>性能测试：</li><li>安全测试：</li><li>兼容性测试：</li><li>文档测试：</li><li>界面测试：</li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rookieIM</title>
    <link href="/2024/05/17/rookieIM/"/>
    <url>/2024/05/17/rookieIM/</url>
    
    <content type="html"><![CDATA[<h1 id="RookieIM"><a href="#RookieIM" class="headerlink" title="RookieIM"></a>RookieIM</h1><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p><img src="/2024/05/17/rookieIM/bimage-20240517205959251.png" alt="image-20240517205959251"></p><p>服务器创建一个socket，绑定主机和端口号（bind），开启监听（listen），然后接收连接（accpet）。客户端同样也是创建一个socket，传递主机号和端口号进行连接（connect）。两端通过write和read请求数据和回应数据。最后都可以关闭连接。</p><ol><li>BIO：Blocking IO，阻塞IO，服务端调用accpet时，若没有连接则会阻塞。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SockerServer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9000</span>);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;等待链接。。&quot;</span>);<br><br>            <span class="hljs-comment">//阻塞</span><br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br><br>            System.out.println(<span class="hljs-string">&quot;客户端进来了&quot;</span>);<br><br>            <span class="hljs-comment">// handler(socket);</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        handler(socket);<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handler</span><span class="hljs-params">(Socket clientSocket)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        System.out.println(<span class="hljs-string">&quot;准备read..&quot;</span>);<br>        <span class="hljs-comment">//接收客户端的数据，阻塞方法，没有数据可读时就阻塞</span><br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> clientSocket.getInputStream().read(bytes);<br><br>            System.out.println(<span class="hljs-string">&quot;read完毕。。&quot;</span>);<br>            <span class="hljs-keyword">if</span> (read != -<span class="hljs-number">1</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;接收到客户端的数据：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes, <span class="hljs-number">0</span>, read));<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li><p>NIO：NO Blocking IO，非阻塞IO，服务器调用accpet时，没有连接也不会阻塞。</p><ol><li>当有连接来时，放入一个set集合里头，之后主动询问这个连接中是否有连接的方法来read数据。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NioServer</span> &#123;<br><br>    <span class="hljs-comment">// 保存客户端连接</span><br>    <span class="hljs-keyword">static</span> List&lt;SocketChannel&gt; channelList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        <span class="hljs-comment">// 创建NIO ServerSocketChannel,与BIO的serverSocket类似</span><br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>        serverSocket.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">9000</span>));<br>        <span class="hljs-comment">// 设置ServerSocketChannel为非阻塞</span><br>        serverSocket.configureBlocking(<span class="hljs-literal">false</span>);<br>        System.out.println(<span class="hljs-string">&quot;服务启动成功&quot;</span>);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 非阻塞模式accept方法不会阻塞，否则会阻塞</span><br>            <span class="hljs-comment">// NIO的非阻塞是由操作系统内部实现的，底层调用了linux内核的accept函数</span><br>            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>            <span class="hljs-keyword">if</span> (socketChannel != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 如果有客户端进行连接</span><br>                System.out.println(<span class="hljs-string">&quot;连接成功&quot;</span>);<br>                <span class="hljs-comment">// 设置SocketChannel为非阻塞</span><br>                socketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>                <span class="hljs-comment">// 保存客户端连接在List中</span><br>                channelList.add(socketChannel);<br>            &#125;<br>            <span class="hljs-comment">// 遍历连接进行数据读取 10w - 1000 读写事件</span><br>            Iterator&lt;SocketChannel&gt; iterator = channelList.iterator();<br>            <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> iterator.next();<br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">128</span>);<br>                <span class="hljs-comment">// 非阻塞模式read方法不会阻塞，否则会阻塞</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> sc.read(byteBuffer);<br>                <span class="hljs-comment">// 如果有数据，把数据打印出来</span><br>                <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 接收到消息：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(byteBuffer.array()));<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len == -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 如果客户端断开，把socket从集合中去掉</span><br>                    iterator.remove();<br>                    System.out.println(<span class="hljs-string">&quot;客户端断开连接&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>通过监听的方式，使用selector机制，存储channel和对应的监听事件，当有事件发生时即selector的select有返回值时，通过判断监听得到的事件，做出对应的任务。</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NioSelectorServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 创建NIO ServerSocketChannel</span><br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>        serverSocket.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">9000</span>));<br>        <span class="hljs-comment">// 设置ServerSocketChannel为非阻塞</span><br>        serverSocket.configureBlocking(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 打开Selector处理Channel，即创建epoll</span><br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>        <span class="hljs-comment">// 把ServerSocketChannel注册到selector上，并且selector对客户端accept连接操作感兴趣</span><br>        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selectionKey</span> <span class="hljs-operator">=</span> serverSocket.register(selector, SelectionKey.OP_ACCEPT);<br>        System.out.println(<span class="hljs-string">&quot;服务启动成功&quot;</span>);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 阻塞等待需要处理的事件发生 已注册事件发生后，会执行后面逻辑</span><br>            selector.select();<br><br>            <span class="hljs-comment">// 获取selector中注册的全部事件的 SelectionKey 实例</span><br>            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();<br><br>            <span class="hljs-comment">// 遍历SelectionKey对事件进行处理</span><br>            <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iterator.next();<br>                <span class="hljs-comment">// 如果是OP_ACCEPT事件，则进行连接获取和事件注册</span><br>                <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.channel();<br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> server.accept();<br>                    socketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>                    <span class="hljs-comment">// 这里只注册了读事件，如果需要给客户端发送数据可以注册写事件</span><br>                    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selKey</span> <span class="hljs-operator">=</span> socketChannel.register(selector, SelectionKey.OP_READ);<br>                    System.out.println(<span class="hljs-string">&quot;客户端连接成功&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;  <span class="hljs-comment">// 如果是OP_READ事件，则进行读取和打印</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">128</span>);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> socketChannel.read(byteBuffer);<br>                    <span class="hljs-comment">// 如果有数据，把数据打印出来</span><br>                    <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>) &#123;<br>                        System.out.println(Thread.currentThread().getName() +  <span class="hljs-string">&quot;接收到消息：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(byteBuffer.array()));<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len == -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 如果客户端断开连接，关闭Socket</span><br>                        System.out.println(<span class="hljs-string">&quot;客户端断开连接&quot;</span>);<br>                        socketChannel.close();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">//从事件集合里删除本次处理的key，防止下次select重复处理</span><br>                iterator.remove();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><ol><li>首先需要导入相应的Netty的maven依赖</li><li>编写一个discardServer类，定义run方法，该方法是启动服务器的主要逻辑。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscardServer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> port;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DiscardServer</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span> &#123;<br>        <span class="hljs-built_in">this</span>.port = port;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//线程池</span><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<span class="hljs-comment">//</span><br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>(); <span class="hljs-comment">// (2)</span><br>            b.group(bossGroup, workerGroup)<br>                    .channel(NioServerSocketChannel.class) <span class="hljs-comment">// (3)</span><br>                    .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123; <span class="hljs-comment">// (4)</span><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            ch.pipeline().addLast(<span class="hljs-string">&quot;decoder&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDecoder</span>()); <span class="hljs-comment">// 添加解码器</span><br>                            ch.pipeline().addLast(<span class="hljs-string">&quot;encoder&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEncoder</span>()); <span class="hljs-comment">// 添加编码器</span><br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleStateHandler</span>(<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HeartbeatHandler</span>());<br>                        &#125;<br>                    &#125;)<br>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)          <span class="hljs-comment">// (5)</span><br>                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>); <span class="hljs-comment">// (6)</span><br><br>            <span class="hljs-comment">// Bind and start to accept incoming connections.</span><br>            System.out.println(<span class="hljs-string">&quot;tcp start success&quot;</span>);<br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> b.bind(port).sync(); <span class="hljs-comment">// (7)</span><br>            <span class="hljs-comment">// Wait until the server socket is closed.</span><br>            <span class="hljs-comment">// In this example, this does not happen, but you can do that to gracefully</span><br>            <span class="hljs-comment">// shut down your server.</span><br>            f.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            workerGroup.shutdownGracefully();<br>            bossGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="3"><li>配置相关的handler类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscardServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Set&lt;Channel&gt; socketChannelSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Channel&gt;();<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 通知其他人，用户上线了</span><br>        socketChannelSet.forEach(e -&gt; &#123;<br>            e.writeAndFlush(<span class="hljs-string">&quot;[客户端]&quot;</span>+ctx.channel().remoteAddress() + <span class="hljs-string">&quot;上线了&quot;</span>);<br>        &#125;);<br><br>        socketChannelSet.add(ctx.channel());<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> (String) msg;<br><br>        socketChannelSet.forEach(e -&gt;&#123;<br>            <span class="hljs-keyword">if</span>(e == ctx.channel())&#123;<br>                e.writeAndFlush(<span class="hljs-string">&quot;[自己]：&quot;</span> + data);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                e.writeAndFlush(<span class="hljs-string">&quot;[客户端]&quot;</span>+ctx.channel().remoteAddress() + <span class="hljs-string">&quot; : &quot;</span> +data);<br>            &#125;<br>        &#125;);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 通知其他客户端，该用户下线了</span><br>        socketChannelSet.remove(ctx.channel());<br>        socketChannelSet.forEach(e -&gt; &#123;<br>            e.writeAndFlush(<span class="hljs-string">&quot;[客户端]&quot;</span>+ctx.channel().remoteAddress() + <span class="hljs-string">&quot;下线了&quot;</span>);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h2><ol><li>心跳机制，主要用来检测连接是否处于活动状态。心跳机制在 Netty 中主要通过 <code>IdleStateHandler</code> 实现。<code>IdleStateHandler</code> 是一个 <code>ChannelHandler</code>，它可以触发 <code>IdleStateEvent</code> 事件，当连接在配置的时间间隔内没有读、写或者两者都没有时，这些事件就会被触发。</li></ol><h2 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h2><ol><li>协议的选择：这里选择了自定义协议，所以需要编写对应的ImServer时，要添加解析客户端传递过来的数据为自定义的Message格式。首先定义一个handler，用于解析客户端传过来的数据成Message，这里可以通过创建一个工具类对ByteBuf进行解析。</li></ol><h3 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h3><h3 id="缓存用户channel"><a href="#缓存用户channel" class="headerlink" title="缓存用户channel"></a>缓存用户channel</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaLearn(2)</title>
    <link href="/2024/05/15/JavaLearn515/"/>
    <url>/2024/05/15/JavaLearn515/</url>
    
    <content type="html"><![CDATA[<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><ol><li><strong>字节流和字符流</strong>：字节流，以Input&#x2F;OutputStream为结尾的类，适合处理二进制数据。字符流，以Writer&#x2F;Reader为结尾的类。适合处理文本数据。</li><li><strong>读入流和写出流</strong>：读和写一般是<strong>基于内存</strong>来解释的，将数据转移到内存即是读入，从文件、键盘（看作文件）读到内存。将数据转移出内存即是写出，一般写出到文件、屏幕（看作文件）。</li><li><strong>文件流&#x2F;数据流&#x2F;对象流</strong>：以File&#x2F;Data&#x2F;Object开头的类。</li><li><strong>缓冲流</strong>：以Bufferd开头的类，用于提高读写操作的效率。底层是通过一个buffer数组实现的。</li><li><strong>转换流</strong>：用来在字节流和字符流之间进行转换的。InputStreamReader实现在字节流到字符流的转换，OutputStreamWriter实现在字符流到字节流的转换。传输时使用二进制传输，在编码时使用字符形式显示。</li></ol><h3 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h3><ol><li>一种高效且易于使用的处理数据的方式，强化了Java集合框架。不存储数据，不改变源数据，惰性执行，可以并行。其操作可以分为中间操作和终端操作。</li><li><strong>中间操作</strong>：<ol><li>filter(Predicate<T>)：过滤元素</T></li><li>map(Fuction&lt;T,R&gt;)：映射每个元素对应的结果</li><li>sorted(Comparator)：排序</li><li>distinct()：去重</li><li>limit(long maxSize)：截断</li></ol></li><li><strong>终端操作</strong>：<ol><li>forEach(Consumer<T>)：迭代每个元素</T></li><li>collect(collector&lt;T,A,R&gt;)：将流转换为其他形式</li><li>count()：返回流中元素的个数</li><li>reduce(BinaryOperator<T>)：通过各个连接操作将所有元素汇总成一个结果</T></li><li>any&#x2F;all&#x2F;noneMatch(Predicate<T>)：匹配操作</T></li><li>findFirst&#x2F;Any()：查找元素</li></ol></li></ol><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ol><li><p>泛型的本质是参数化类型，即数据类型不确定，允许在编译时指定类、接口或者方法的中参数的类型（这种参数的类型不确定的参数叫做类型参数）。有泛型方法和泛型类两种。泛型就是为了可以实现处理多种类型，有时候还可以对参数类型进行限制，例如使用&lt;T extend &#x2F; super Number&gt;来实现。</p></li><li><p>泛型是通过类型擦除来实现的，类型擦除就是将所有的泛型类型参数替换掉，并且在必要的地方插入类型转换代码，以便程序可以正常运行。首先将类型擦除到其边界，extends擦除到其父类，无界和super则擦除到Object，这样之后就使用了Java的多态的机制。而在必要时将插入类型的转换，来保证类型的安全。</p></li><li><p>泛型方法：</p><ol><li><T>声明在返回类型之前。</T></li><li>可用来声明返回值类型，也可用来声明方法的传入参数的类型。</li><li>类型参数只能代表引用类型，不能是基础类型（如：int，double）</li></ol></li><li><p>泛型类：</p><ol><li><T>声明在类名之后。</T></li></ol></li></ol><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><ol><li>java5引入的<strong>元数据</strong>（meta data），它允许将信息和元数据添加到代码中，而不会直接影响代码的执行。被用来为代码提供额外的信息。可以在编译时、类加载时或者运行时被读取，并且可以影响到编译器、工具和库的行为。</li><li><strong>元注解</strong>：<ol><li>@Retention： 指定注解的保留策略，有SOUCRE（存在于源代码，例如@override）、CLASS（自定义注解.例如AOP)和RUNTIME（存在于运行时，spring框架中常用）</li><li>Target：指定注解可以应用于Java元素类型，METHOD或者FIELD。</li><li>Inherited：指定注解类型会被子类继承。</li><li>@Documented：指示将次注解包含在javaDoc中。</li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaLearn(1)</title>
    <link href="/2024/05/14/JavaLearning514/"/>
    <url>/2024/05/14/JavaLearning514/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaLearn514"><a href="#JavaLearn514" class="headerlink" title="JavaLearn514"></a>JavaLearn514</h1><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><ol><li><strong>getClass</strong>   navtive方法，获取该对象的Class对象，Class对象就是字节码文件，保存在堆中。</li><li><strong>hashCode</strong>   native方法，主要作用就是获得该对象的哈希值，哈希算法就是一种将数据转换为固定大小输出值的算法，例如String类中的hashCode就重写了，具体算法是依次遍历每个字符，初始h为0， h &#x3D; h * 31 + value[i] 。为什么是31，因为31是是一个奇质数，质数能减少哈希碰撞的概率，而且31比较好计算，左移五位后再删除自身。</li><li><strong>equals</strong>   用于比较两个对象，未重写即是 <code>this == obj</code> 的形式，比较两个对象的引用地址。子类需要比较时一般要重写这个方法。</li><li><strong>clone</strong> native方法，实现对象的浅拷贝。只有实现了Cloneable接口才可以调用该方法。否则会抛出CloneNotSupportException异常。浅拷贝和深拷贝是复制对象时的两种不同策略。浅拷贝创建的是一个新对象，这个新对象拥有和原始对象相同的属性值。如果是基本数据类型，则复制属性值，如果是引用数据类型，则会复制该属性指向的内存地址，而不是该属性指向的实际对象。深拷贝则是会递归的复制一个原始对象的所有引用对象。</li><li><strong>toString</strong> 返回一个String对象，一般子类都有覆盖。默认返回格式如下：<code>getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode())</code>。</li><li><strong>wait</strong>(time) 将该线程暂停，放弃当前持有的锁，进入的对应的对象锁的监视器的等待集中。  </li><li><strong>notify</strong> 用于唤醒在该对象上等待的某个线程。用于唤醒在该对象的监视器的等待集里头的线程</li><li><strong>finalize</strong> 该方法是保护方法，主要用于在GC的时候再次被调用，如果我们实现了这个方法，对象可能在这个方法中再次复活，从而避免被GC回收。</li></ol><h2 id="Thread的方法"><a href="#Thread的方法" class="headerlink" title="Thread的方法"></a>Thread的方法</h2><ol><li><strong>start</strong> 实例方法，java虚拟机调用此线程的run方法</li><li><strong>sleep</strong> 使当前正在执行的线程暂停执行指定的时间，以让其他线程执行</li><li><strong>yield</strong> 暗示调度器当前线程愿意让出当前的CPU资源</li><li><strong>join</strong> 实例方法，加入的意思，等待这个线程终止。一般是在一个线程调用另一个线程，使其加入，即执行加入的线程先。</li><li><strong>interrupt</strong> 实例方法，用于中断线程</li><li><strong>stop</strong> 强制终止线程，已弃用，不安全</li><li><strong>currentThead</strong> 返回对当前正在执行的线程对象的引用</li><li><strong>getName getId getpriority getState</strong> 返回线程名称 标识符 优先级 状态，也有对应的set方法</li></ol><h2 id="wait-和sleep-的区别"><a href="#wait-和sleep-的区别" class="headerlink" title="wait()和sleep()的区别"></a>wait()和sleep()的区别</h2><ol><li>wait是Object的实例方法，每个对象都有这个方法，常用的就是直接wait()，表示执行当前方法的线程<strong>释放</strong>它持有的对象锁，进入到锁的等待集中，允许其他线程进入同步代码块或方法。需要在synchronized代码块或者wait方法中使用，否则会排除illegalMonitorStateException异常，因为要调用wait之前需要持有一个对象锁。需要通过notify()方法唤醒当前对象锁上等待的线程。平时一般都是在一个类中写这些方法，当前线程和对象都是同一个。</li><li>sleep是Thread的静态方法，执行sleep()方法时它<strong>不会释放</strong>任何锁。可以在任何地方使用，不需要在同步代码块中。通常用于延迟执行，或者在特定的时间内让出CPU给其他线程执行。</li></ol><h2 id="synchronized和ReentrantLock的原理和区别"><a href="#synchronized和ReentrantLock的原理和区别" class="headerlink" title="synchronized和ReentrantLock的原理和区别"></a>synchronized和ReentrantLock的原理和区别</h2><ol><li><p><strong>对象创建流程</strong>：通过new关键字创建对象时，一般是先检查对象对应的类是否已加载，未记载则执行对应的类加载（加载，链接（验证、准备、解析）、初始化），加载后分配内存，内存分配策略有指针碰撞和空闲列表两种方式。接着初始化零值，对属性赋值。<strong>设置对象头</strong>，执行 init 方法，也就是构造器方法，父类子类构造器合在一起。</p></li><li><p><strong>对象头信息</strong>：Mark Word（哈希码、GC代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳） 和类型指针（指向它的类元数据的指针）和数组长度。MarkWord的长度一般跟JVM的位数一致，例如JVM是64位，MarkWord就是64位。为了能使用更少的位数存放更多的信息，最低的2位的用来标志为锁的类型，根据锁的类型的不同，前面的位表示的信息也不同。例如当是重量级锁时前62位是ptr-to-heavyweight-monitor，表示指向monitor对象（也称为管程或监视器锁）的起始地址。</p></li><li><p><strong>synchronized的原理</strong>：涉及JVM中的监视器锁或者对象锁机制,每个对象有对应的监视器monitor，也和对象的对象头信息有关。可以修饰方法和代码块，修饰时需要传递一个对象作为锁。当一个线程访问某个对象的synchronized方法时，他会自动获取这个方法所属对象的锁。</p></li><li><p><strong>监视器</strong>：用于实现线程之间的的互斥和协作。每个java对象都可以关联一个监视器，如果另一个线程视图进入使用同一个监视器锁保护的另一个同步代码段，它会被阻塞直到监视器被释放。监视器的实现通常包含以下几个部分：锁（Lock）、等待集（Wait Set）[线程调用wait()方法时它会被放入到监视器的等待集中，处于等待集中的线程不会竞争锁，而是等待被notify()或者notifyAll()方法唤醒]、计数器[]。</p></li><li><p><strong>synchronized锁的状态</strong>：有多种状态，如无锁状态、偏向锁、轻量级锁和重量级锁。他们在不同情况下会通过CAS、自旋等方式及逆行锁状态转换，以提高同步的效率。</p></li><li><p><strong>对象锁的状态变化</strong>： 一开始是无锁状态，当第一个线程尝试进入synchronized方法时，如果没有其他线程竞争该锁，则JVM会将对象头的Mark Word更新为偏向锁的状态。根据情况的不同，偏向锁升级为轻量级锁或者重量级锁。轻量级锁适用于多线程交替执行同步块的情况，而非同时竞争。重量级锁同时竞争同一把锁的情况。</p></li><li><p><strong>偏向锁的理解</strong>：偏向，就是倾向的意思，偏向锁即时偏向于第一个获取它的线程。在多线程的应用程序中，很多情况下锁往往是由一个线程多次连续获取，传统的锁机制（轻量级锁和重量级锁）每次在进入和退出临界区时都需要进行一些列复杂的同步操作。即使没有其他线程竞争该锁，这些操作在无竞争的情况下引入了不必要的性能开销。偏向锁就是为了优化这种情况而引入的。</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2024/03/07/Git/"/>
    <url>/2024/03/07/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h1><p>🦐🦀🦞</p><h2 id="Git的基础介绍"><a href="#Git的基础介绍" class="headerlink" title="Git的基础介绍"></a>Git的基础介绍</h2><p>🦞 <strong>基本介绍</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tex">Git是一个分布式版本控制系统。<br><br>版本控制，即一种记录文件内容变化，一边将来查阅特定版本修订情况。用户能够查看历史版本，方便版本之间的切换。<br><br>分布式，与之相反的是集中式。常见集中式版本控制工具由CVS、SVN（Subversion）、VSS...。<br>集中式则是一个单一的集中管理的服务器，保存所有文件的修订版本，工作者通过客户端连接服务器，取得最新文件或者提供更新。但一旦服务器宕机，后果很严重。<br><br>分布式，工作者吧代码从仓库完整地镜像到本地库，在本地库进行修改。在本地进行版本控制。<br></code></pre></td></tr></table></figure><p>🦞 <strong>工作原理</strong></p><p><img src="/2024/03/07/Git/image-20240307220422821.png" alt="image-20240307220422821">Git</p><h2 id="Git的基本指令"><a href="#Git的基本指令" class="headerlink" title="Git的基本指令"></a>Git的基本指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 初始化本地库<br>git init<br>2.查看本地库状态<br>git status<br>3. 添加暂存区，当文件名为 . 时，表示当前目录下所有文件<br>git add 文件名<br>4. 提交到本地库<br>git commit -m “日志信息” 文件名<br>5. 查看历史版本<br>git relog/log<br>6. 切换版本<br>git reset -- hard 版本号<br></code></pre></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>🦞 <strong>何为分支</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务地单独分支。使用分支以为这程序员可以把自己地工作从开发主线分离开来，开发自己分支的时候，不会影响主线的运行。<br><br>分支底层其实也是指针的引用。<br></code></pre></td></tr></table></figure><p>🦞 <strong>分支的基本操作</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.查看分支<br>git branch -v<br>2.切换分支<br>git checkout 分支名<br>3.创建分支<br>git branch 分支名<br>4.合并分支，将指定的分支合并到当前分支上<br>git merge 分支名<br></code></pre></td></tr></table></figure><p>🦞 <strong>合并分支时产生冲突</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">合并分支时，两个分支在同一个文件的同一个位置由两套王权不同的修改，Git无法替我们决定使用哪一个，即需认为决定新代码的内容。<br></code></pre></td></tr></table></figure><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>🦞 <strong>远程仓库基本指令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 拉取仓库代码，将远程仓库对于分支最新内容拉下来后于当前分支直接合并<br>git pull 远程仓库地址别名 远程分支名<br>2. 上传仓库代码，推送本地分支上的内容到远程仓库<br>git push 别名 本地分支<br>3. 克隆仓库代码，<span class="hljs-built_in">clone</span> = 拉取代码 + 初始化本地仓库 + 创建别名（origin）<br>git <span class="hljs-built_in">clone</span> 远程地址<br>4. 建立仓库连接<br>git remote add 别名 远程地址<br>5. 查看当前所有远程地址别名<br>git remote -v<br></code></pre></td></tr></table></figure><p>🦞 <strong>跨平台团队写作</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">首先通过fork将指定的仓库代码复制到自己的github仓库，然后对自己的github仓库代码拉到本地，进行修改创作等等，再推回github仓库。最后向原仓库提交PR，也就是pull request。在PR里头可以看到相关信息。<br></code></pre></td></tr></table></figure><h2 id="工作中正确使用git"><a href="#工作中正确使用git" class="headerlink" title="工作中正确使用git"></a>工作中正确使用git</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tex">1、 先把master主分支上的代码与远程仓库同步到最新版本。直接从远程仓库pull下来<br>2、 在本地创建并切换到工作分支，创建完成后会自动切换到该分支（这时候master/work分支的内容是相同的。）<br>3、 编写代码。<br>4、 完成后，add commit到work分支<br>5、 将主分支从远程仓库pull最新的版本下来。<br>6、 将工作分支合并到主分支<br>先切换到主分支master<br>选中要合并的分支work，点击merge<br>如果有冲突，则需要手动解决冲突<br>7、 这时候所有在work分支上做得修改就会合并到主分支上。<br>8、 最后就可以push到远程仓库上了。<br>关于分支切换的两个注意点<br><br>分支切换一定要先add/commit当前分支上的修改，然后如果在修改完代码后没有提交，就想切换，idea会提示是否进行smart checkou，如果你点击yes你就完完了，idea会把当代分支上的修改，保存到你要切换的另一个分支上。这样一样就乱套了。<br>如果当前工作分支上有很多bug不想提交，那么你可以先隐藏当前工作分支上的修改，stash（隐藏），然后切换到另一个分支上，那么下次你又切换回工作分支的时候，你可以通过unstash把修改的代码重新显示出来。<br></code></pre></td></tr></table></figure><p>🦞 <strong>引用</strong></p><p><a href="https://blog.csdn.net/weixin_44190665/article/details/118024018">尚硅谷2021最新Git教程笔记_idea集成gitlab mac-CSDN博客</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL架构篇</title>
    <link href="/2024/03/06/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87/"/>
    <url>/2024/03/06/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="架构篇"><a href="#架构篇" class="headerlink" title="架构篇"></a>架构篇</h2><h3 id="数据目录"><a href="#数据目录" class="headerlink" title="数据目录"></a>数据目录</h3><p>🤥 <strong>表在文件系统中的表示</strong></p><p>​😀 <strong>表结构（以innodb为例）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">表名.frm<br>用于描述表结构的文件，是以二进制格式存储的。<br><br>CREATE TABLE test(<br>c1 INT;<br>    C2 VARCHAR(10)<br>);<br></code></pre></td></tr></table></figure><p>​😀 <strong>系统表空间和独立表空间</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">表空间：用于存放表的数据和索引<br>系统表空间：版本低时采用的策略，所有表的数据和索引都存放在此，大小为12M，且可拓展。文件表名通常为ibdata1。<br>独立表空间：每个表对应属于自个的表空间，文件格式为“表名.ibd”。<br><br>MySQL8.0中不再单独提供b.frm，二十合并在b.ibd文件中。<br>相比于innodb，myisam则是产生3个文件，除了b.frm(5.7)/b.xxx.sdi(8.0)还有b.MYD和b.MYI，分别存放数据和索引。<br></code></pre></td></tr></table></figure><h3 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h3><p>🤥 <strong>剖析逻辑架构</strong></p><p><img src="/2024/03/06/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87/image-20240304172052923.png"></p><p>​😀 <strong>连接层</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">访问MySQL服务器前，第一件事就是建立TCP链接。涉及到了三次握手（计网知识）。<br>TCP链接收到请求后，会分配给一个线程与这个客户端进行交互，所以还会有个线程池。<br>有了线程池，省去了创建和销毁的开销。<br></code></pre></td></tr></table></figure><p>​😀 <strong>服务层</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tex">SQL Interface SQL接口 --&gt;  Parser 解析器--&gt;  Optimizer 查询优化器<br><br>SQL接口：接收SQL命令，并且返回查询结构。例如select * from xxx；<br><br>解析器：对SQL命令进行语法解析和语义解析，转换成数据结构，若在转换过程中发生错误，则代表SQL语句不合法。<br><br>查询优化器：语法解析之后、查询之前会使用查询优化器确定SQL的执行路径，生成一个 执行计划 。<br>执行计划会表明使用哪些 索引 进行查询，表之间连接顺序如何等等。例如有“选取-投影-连接”策略。<br>先进行where，再选择对应属性列，再进行表之间的连接。<br><br>查询缓存：缓存SQL查询结果，由于命中率低，在MySQL8.0中已删除。<br></code></pre></td></tr></table></figure><p>​😀 <strong>引擎层</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">全称为插件式存储引擎层。真正负责数据的存储和提取，对物理服务器级别维护的底层数据执行操作，服务器通过API与存储引擎进行通信。<br>默认的MySQL的存储引擎为InnoDB，支持事务，行级锁，外键。<br></code></pre></td></tr></table></figure><p>​😀 <strong>存储层</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">所有的数据（表数据、索引，数据库信息等）都存在文件系统中。<br></code></pre></td></tr></table></figure><p>🤥<strong>SQL执行流程</strong></p><p><img src="/2024/03/06/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87/image-20240304172159984.png" alt="image-20240304172159984"></p><p>​😀 <strong>SQL执行流程文字描述</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">1. 建立CS通信连接<br>2. 查询缓存<br>3. 对SQL语句进行语法分析、语义分析，生成对应语法树（即为图中的语法解析和预处理）<br>4. 确定执行路径，生成执行计划，包括逻辑查询优化和物理查询优化。<br>5. 执行生成的执行计划<br></code></pre></td></tr></table></figure><p>😀 <strong>SQL语法顺序</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">优化器会分析不同的执行顺序产生的性能消耗不同而动态调整执行顺序。下表是常见的查询顺序。<br></code></pre></td></tr></table></figure><p><img src="/2024/03/06/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87/image-20240304204224911.png" alt="image-20240304204224911"></p><p>😀 <strong>profiles、profiling、profile的使用</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">使用profile可以查看SQL语句的详细执行步骤<br><br>有全局参数 profiling， 使用 select @@profiling ，即可查看。默认该功能关闭，可通过 set profiling = 1 进行设置。<br><br>使用 show profiles 可以查看当前会话所产生的最近几次查询<br><br></code></pre></td></tr></table></figure><p>🤥<strong>数据库缓冲池</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">略<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown基本语法</title>
    <link href="/2024/03/03/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2024/03/03/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="MarkDown语法"><a href="#MarkDown语法" class="headerlink" title="MarkDown语法"></a>MarkDown语法</h1><p>[TOC]</p><h3 id="标题（-）"><a href="#标题（-）" class="headerlink" title="标题（#）"></a>标题（#）</h3><p>标题采用 # 来标注</p><h3 id="强调（-）"><a href="#强调（-）" class="headerlink" title="强调（*）"></a>强调（*）</h3><p>粗体的话使用两个 ** ，斜体的话使用一个 *</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">正常   ** 粗体 **    <span class="hljs-emphasis">*斜体*</span>     <span class="hljs-strong">**<span class="hljs-emphasis">*粗斜体*</span>**</span> <br></code></pre></td></tr></table></figure><h3 id="引用-（-）"><a href="#引用-（-）" class="headerlink" title="引用 （&gt;）"></a>引用 （&gt;）</h3><p>引用的话使用 &gt;</p><blockquote><p>这是引用</p></blockquote><h3 id="列表-（-）"><a href="#列表-（-）" class="headerlink" title="列表 （-）"></a>列表 （-）</h3><p>列表分为有序和无序，有序使用数字加英文小数点，无序使用 - * + 任一。要在保留列表的连续性的同时在列表中添加另一种元素，请将改元素缩进四个空格或一个制表符。</p><ol><li><p>有序第一条</p></li><li><p>有序第二条</p><ol><li><p>这是缩进</p><blockquote><p>这是列表中的另一个元素</p></blockquote></li><li><p>这是缩进</p></li></ol></li></ol><ul><li>无序第一条</li><li>无序第二条</li></ul><h3 id="代码（-）"><a href="#代码（-）" class="headerlink" title="代码（&#96;）"></a>代码（&#96;）</h3><p> 这个符号叫反引号，用法类似于强调的 *，一两层 &#96; 表示 代码，可在两层中使用一层，类似于python的引号， 三层则是代码块</p><p><code>int</code></p><p><code>int</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">这是java代码块</span><br><span class="hljs-comment">**/</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="分割线（-，—-）"><a href="#分割线（-，—-）" class="headerlink" title="分割线（***，—,___）"></a>分割线（***，—,___）</h3><p>分割线有三种，需要在单独一行里使用。建议使用 —，渲染效果都一样</p><hr><hr><hr><h3 id="链接-超链接显示名-超链接地址-“超链接标签”"><a href="#链接-超链接显示名-超链接地址-“超链接标签”" class="headerlink" title="链接 [超链接显示名] (超链接地址 “超链接标签”)"></a>链接 [超链接显示名] (超链接地址 “超链接标签”)</h3><p>超链接标签是鼠标停在链接上显示的提示词。一般使用鼠标右键来创建超链接，或者直接复制链接到笔记里头。</p><p><a href="https://markdown.com.cn/basic-syntax/links.html">Markdown 链接语法 | Markdown 官方教程</a></p><p>使用尖括号可以很方便地把URL或者email地址变成可点击的链接。</p><p><a href="https://jokkerli.github.io/">https://jokkerli.github.io/</a></p><h3 id="图片-图片显示名-图片"><a href="#图片-图片显示名-图片" class="headerlink" title="图片 ![图片显示名] (图片)"></a>图片 ![图片显示名] (图片)</h3><p>类似于超链接，多了一个！。给图片添加链接时，将图片的 ![] () 放入到超链接的[超链接显示名]中即可。</p><p><a href="https://markdown.com.cn/basic-syntax/images.html"><img src="/2024/03/03/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/TyporaMd\90.jpg" alt="老头"></a></p><h3 id="转义字符语法"><a href="#转义字符语法" class="headerlink" title="转义字符语法"></a>转义字符语法</h3><p>要想显示原本用于格式化的mk字符，需在字符前面添加反斜杠字符 \ 。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>表格、公式块、任务列表、链接引用等使用，可通过右键直接添加。</p><p>同时，为了添加笔记的美观，可以适当地添加一些emoji表情。可通过以下链接获得表情。</p><p><a href="https://emojipedia.org/">📙 Emojipedia — 😃 Home of Emoji Meanings 💁👌🎍😍</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>再次学习markdown的语法，为了能更好地写笔记，希望这是一个好的开始吧。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/02/29/hello-world/"/>
    <url>/2024/02/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
