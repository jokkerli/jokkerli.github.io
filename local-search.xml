<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2024/03/07/Git/"/>
    <url>/2024/03/07/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h1><p>🦐🦀🦞</p><h2 id="Git的基础介绍"><a href="#Git的基础介绍" class="headerlink" title="Git的基础介绍"></a>Git的基础介绍</h2><p>🦞 <strong>基本介绍</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tex">Git是一个分布式版本控制系统。<br><br>版本控制，即一种记录文件内容变化，一边将来查阅特定版本修订情况。用户能够查看历史版本，方便版本之间的切换。<br><br>分布式，与之相反的是集中式。常见集中式版本控制工具由CVS、SVN（Subversion）、VSS...。<br>集中式则是一个单一的集中管理的服务器，保存所有文件的修订版本，工作者通过客户端连接服务器，取得最新文件或者提供更新。但一旦服务器宕机，后果很严重。<br><br>分布式，工作者吧代码从仓库完整地镜像到本地库，在本地库进行修改。在本地进行版本控制。<br></code></pre></td></tr></table></figure><p>🦞 <strong>工作原理</strong></p><p><img src="/2024/03/07/Git/image-20240307220422821.png" alt="image-20240307220422821">Git</p><h2 id="Git的基本指令"><a href="#Git的基本指令" class="headerlink" title="Git的基本指令"></a>Git的基本指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 初始化本地库<br>git init<br>2.查看本地库状态<br>git status<br>3. 添加暂存区，当文件名为 . 时，表示当前目录下所有文件<br>git add 文件名<br>4. 提交到本地库<br>git commit -m “日志信息” 文件名<br>5. 查看历史版本<br>git relog/log<br>6. 切换版本<br>git reset -- hard 版本号<br></code></pre></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>🦞 <strong>何为分支</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务地单独分支。使用分支以为这程序员可以把自己地工作从开发主线分离开来，开发自己分支的时候，不会影响主线的运行。<br><br>分支底层其实也是指针的引用。<br></code></pre></td></tr></table></figure><p>🦞 <strong>分支的基本操作</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.查看分支<br>git branch -v<br>2.切换分支<br>git checkout 分支名<br>3.创建分支<br>git branch 分支名<br>4.合并分支，将指定的分支合并到当前分支上<br>git merge 分支名<br></code></pre></td></tr></table></figure><p>🦞 <strong>合并分支时产生冲突</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">合并分支时，两个分支在同一个文件的同一个位置由两套王权不同的修改，Git无法替我们决定使用哪一个，即需认为决定新代码的内容。<br></code></pre></td></tr></table></figure><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>🦞 <strong>远程仓库基本指令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 拉取仓库代码，将远程仓库对于分支最新内容拉下来后于当前分支直接合并<br>git pull 远程仓库地址别名 远程分支名<br>2. 上传仓库代码，推送本地分支上的内容到远程仓库<br>git push 别名 本地分支<br>3. 克隆仓库代码，<span class="hljs-built_in">clone</span> = 拉取代码 + 初始化本地仓库 + 创建别名（origin）<br>git <span class="hljs-built_in">clone</span> 远程地址<br>4. 建立仓库连接<br>git remote add 别名 远程地址<br>5. 查看当前所有远程地址别名<br>git remote -v<br></code></pre></td></tr></table></figure><p>🦞 <strong>跨平台团队写作</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">首先通过fork将指定的仓库代码复制到自己的github仓库，然后对自己的github仓库代码拉到本地，进行修改创作等等，再推回github仓库。最后向原仓库提交PR，也就是pull request。在PR里头可以看到相关信息。<br></code></pre></td></tr></table></figure><h2 id="工作中正确使用git"><a href="#工作中正确使用git" class="headerlink" title="工作中正确使用git"></a>工作中正确使用git</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tex">1、 先把master主分支上的代码与远程仓库同步到最新版本。直接从远程仓库pull下来<br>2、 在本地创建并切换到工作分支，创建完成后会自动切换到该分支（这时候master/work分支的内容是相同的。）<br>3、 编写代码。<br>4、 完成后，add commit到work分支<br>5、 将主分支从远程仓库pull最新的版本下来。<br>6、 将工作分支合并到主分支<br>先切换到主分支master<br>选中要合并的分支work，点击merge<br>如果有冲突，则需要手动解决冲突<br>7、 这时候所有在work分支上做得修改就会合并到主分支上。<br>8、 最后就可以push到远程仓库上了。<br>关于分支切换的两个注意点<br><br>分支切换一定要先add/commit当前分支上的修改，然后如果在修改完代码后没有提交，就想切换，idea会提示是否进行smart checkou，如果你点击yes你就完完了，idea会把当代分支上的修改，保存到你要切换的另一个分支上。这样一样就乱套了。<br>如果当前工作分支上有很多bug不想提交，那么你可以先隐藏当前工作分支上的修改，stash（隐藏），然后切换到另一个分支上，那么下次你又切换回工作分支的时候，你可以通过unstash把修改的代码重新显示出来。<br></code></pre></td></tr></table></figure><p>🦞 <strong>引用</strong></p><p><a href="https://blog.csdn.net/weixin_44190665/article/details/118024018">尚硅谷2021最新Git教程笔记_idea集成gitlab mac-CSDN博客</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL架构篇</title>
    <link href="/2024/03/06/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87/"/>
    <url>/2024/03/06/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="架构篇"><a href="#架构篇" class="headerlink" title="架构篇"></a>架构篇</h2><h3 id="数据目录"><a href="#数据目录" class="headerlink" title="数据目录"></a>数据目录</h3><p>🤥 <strong>表在文件系统中的表示</strong></p><p>​😀 <strong>表结构（以innodb为例）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">表名.frm<br>用于描述表结构的文件，是以二进制格式存储的。<br><br>CREATE TABLE test(<br>c1 INT;<br>    C2 VARCHAR(10)<br>);<br></code></pre></td></tr></table></figure><p>​😀 <strong>系统表空间和独立表空间</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">表空间：用于存放表的数据和索引<br>系统表空间：版本低时采用的策略，所有表的数据和索引都存放在此，大小为12M，且可拓展。文件表名通常为ibdata1。<br>独立表空间：每个表对应属于自个的表空间，文件格式为“表名.ibd”。<br><br>MySQL8.0中不再单独提供b.frm，二十合并在b.ibd文件中。<br>相比于innodb，myisam则是产生3个文件，除了b.frm(5.7)/b.xxx.sdi(8.0)还有b.MYD和b.MYI，分别存放数据和索引。<br></code></pre></td></tr></table></figure><h3 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h3><p>🤥 <strong>剖析逻辑架构</strong></p><p><img src="/2024/03/06/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87/image-20240304172052923.png"></p><p>​😀 <strong>连接层</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">访问MySQL服务器前，第一件事就是建立TCP链接。涉及到了三次握手（计网知识）。<br>TCP链接收到请求后，会分配给一个线程与这个客户端进行交互，所以还会有个线程池。<br>有了线程池，省去了创建和销毁的开销。<br></code></pre></td></tr></table></figure><p>​😀 <strong>服务层</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tex">SQL Interface SQL接口 --&gt;  Parser 解析器--&gt;  Optimizer 查询优化器<br><br>SQL接口：接收SQL命令，并且返回查询结构。例如select * from xxx；<br><br>解析器：对SQL命令进行语法解析和语义解析，转换成数据结构，若在转换过程中发生错误，则代表SQL语句不合法。<br><br>查询优化器：语法解析之后、查询之前会使用查询优化器确定SQL的执行路径，生成一个 执行计划 。<br>执行计划会表明使用哪些 索引 进行查询，表之间连接顺序如何等等。例如有“选取-投影-连接”策略。<br>先进行where，再选择对应属性列，再进行表之间的连接。<br><br>查询缓存：缓存SQL查询结果，由于命中率低，在MySQL8.0中已删除。<br></code></pre></td></tr></table></figure><p>​😀 <strong>引擎层</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">全称为插件式存储引擎层。真正负责数据的存储和提取，对物理服务器级别维护的底层数据执行操作，服务器通过API与存储引擎进行通信。<br>默认的MySQL的存储引擎为InnoDB，支持事务，行级锁，外键。<br></code></pre></td></tr></table></figure><p>​😀 <strong>存储层</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">所有的数据（表数据、索引，数据库信息等）都存在文件系统中。<br></code></pre></td></tr></table></figure><p>🤥<strong>SQL执行流程</strong></p><p><img src="/2024/03/06/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87/image-20240304172159984.png" alt="image-20240304172159984"></p><p>​😀 <strong>SQL执行流程文字描述</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">1. 建立CS通信连接<br>2. 查询缓存<br>3. 对SQL语句进行语法分析、语义分析，生成对应语法树（即为图中的语法解析和预处理）<br>4. 确定执行路径，生成执行计划，包括逻辑查询优化和物理查询优化。<br>5. 执行生成的执行计划<br></code></pre></td></tr></table></figure><p>😀 <strong>SQL语法顺序</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">优化器会分析不同的执行顺序产生的性能消耗不同而动态调整执行顺序。下表是常见的查询顺序。<br></code></pre></td></tr></table></figure><p><img src="/2024/03/06/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87/image-20240304204224911.png" alt="image-20240304204224911"></p><p>😀 <strong>profiles、profiling、profile的使用</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">使用profile可以查看SQL语句的详细执行步骤<br><br>有全局参数 profiling， 使用 select @@profiling ，即可查看。默认该功能关闭，可通过 set profiling = 1 进行设置。<br><br>使用 show profiles 可以查看当前会话所产生的最近几次查询<br><br></code></pre></td></tr></table></figure><p>🤥<strong>数据库缓冲池</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">略<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown基本语法</title>
    <link href="/2024/03/03/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2024/03/03/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="MarkDown语法"><a href="#MarkDown语法" class="headerlink" title="MarkDown语法"></a>MarkDown语法</h1><p>[TOC]</p><h3 id="标题（-）"><a href="#标题（-）" class="headerlink" title="标题（#）"></a>标题（#）</h3><p>标题采用 # 来标注</p><h3 id="强调（-）"><a href="#强调（-）" class="headerlink" title="强调（*）"></a>强调（*）</h3><p>粗体的话使用两个 ** ，斜体的话使用一个 *</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">正常   ** 粗体 **    <span class="hljs-emphasis">*斜体*</span>     <span class="hljs-strong">**<span class="hljs-emphasis">*粗斜体*</span>**</span> <br></code></pre></td></tr></table></figure><h3 id="引用-（-）"><a href="#引用-（-）" class="headerlink" title="引用 （&gt;）"></a>引用 （&gt;）</h3><p>引用的话使用 &gt;</p><blockquote><p>这是引用</p></blockquote><h3 id="列表-（-）"><a href="#列表-（-）" class="headerlink" title="列表 （-）"></a>列表 （-）</h3><p>列表分为有序和无序，有序使用数字加英文小数点，无序使用 - * + 任一。要在保留列表的连续性的同时在列表中添加另一种元素，请将改元素缩进四个空格或一个制表符。</p><ol><li><p>有序第一条</p></li><li><p>有序第二条</p><ol><li><p>这是缩进</p><blockquote><p>这是列表中的另一个元素</p></blockquote></li><li><p>这是缩进</p></li></ol></li></ol><ul><li>无序第一条</li><li>无序第二条</li></ul><h3 id="代码（-）"><a href="#代码（-）" class="headerlink" title="代码（&#96;）"></a>代码（&#96;）</h3><p> 这个符号叫反引号，用法类似于强调的 *，一两层 &#96; 表示 代码，可在两层中使用一层，类似于python的引号， 三层则是代码块</p><p><code>int</code></p><p><code>int</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">这是java代码块</span><br><span class="hljs-comment">**/</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="分割线（-，—-）"><a href="#分割线（-，—-）" class="headerlink" title="分割线（***，—,___）"></a>分割线（***，—,___）</h3><p>分割线有三种，需要在单独一行里使用。建议使用 —，渲染效果都一样</p><hr><hr><hr><h3 id="链接-超链接显示名-超链接地址-“超链接标签”"><a href="#链接-超链接显示名-超链接地址-“超链接标签”" class="headerlink" title="链接 [超链接显示名] (超链接地址 “超链接标签”)"></a>链接 [超链接显示名] (超链接地址 “超链接标签”)</h3><p>超链接标签是鼠标停在链接上显示的提示词。一般使用鼠标右键来创建超链接，或者直接复制链接到笔记里头。</p><p><a href="https://markdown.com.cn/basic-syntax/links.html">Markdown 链接语法 | Markdown 官方教程</a></p><p>使用尖括号可以很方便地把URL或者email地址变成可点击的链接。</p><p><a href="https://jokkerli.github.io/">https://jokkerli.github.io/</a></p><h3 id="图片-图片显示名-图片"><a href="#图片-图片显示名-图片" class="headerlink" title="图片 ![图片显示名] (图片)"></a>图片 ![图片显示名] (图片)</h3><p>类似于超链接，多了一个！。给图片添加链接时，将图片的 ![] () 放入到超链接的[超链接显示名]中即可。</p><p><a href="https://markdown.com.cn/basic-syntax/images.html"><img src="/2024/03/03/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/TyporaMd\90.jpg" alt="老头"></a></p><h3 id="转义字符语法"><a href="#转义字符语法" class="headerlink" title="转义字符语法"></a>转义字符语法</h3><p>要想显示原本用于格式化的mk字符，需在字符前面添加反斜杠字符 \ 。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>表格、公式块、任务列表、链接引用等使用，可通过右键直接添加。</p><p>同时，为了添加笔记的美观，可以适当地添加一些emoji表情。可通过以下链接获得表情。</p><p><a href="https://emojipedia.org/">📙 Emojipedia — 😃 Home of Emoji Meanings 💁👌🎍😍</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>再次学习markdown的语法，为了能更好地写笔记，希望这是一个好的开始吧。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/02/29/hello-world/"/>
    <url>/2024/02/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
